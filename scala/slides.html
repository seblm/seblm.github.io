<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Programmation fonctionnelle avec Scala</title>

		<meta name="description" content="Cours sur la programmation fonctionnelle avec Scala">
		<meta name="author" content="Sébastian Le Merdy">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0">

		<link rel="stylesheet" href="../lib/revealjs/dist/reset.css">
		<link rel="stylesheet" href="../lib/revealjs/dist/reveal.css">
		<link rel="stylesheet" href="../lib/revealjs/dist/theme/beige.css" id="theme">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="../lib/revealjs/plugin/highlight/monokai.css">
	</head>

	<body>

		<div class="reveal">

			<div class="slides">

<!--
          Nom matière : Programmation fonctionnelle avec Scala
     Objectif matière : Ce cours a pour objectif de présenter les concepts de la programmation fonctionnelle. Il est en
                        effet important pour un élève ingénieur d’être familier avec les différents paradigmes qui
                        fondent les nombreux langages de programmation qu’ils seront amenés à utiliser ou à comprendre
                        car étant aujourd’hui adoptés de plus en plus dans de nombreux langages populaires (Python, Java
                        8, Javascript, Rust…).
                        L’introduction des concepts inhérents au paradigme fonctionnel seront introduits en début de
                        cours et ce de façon indépendante d’un langage de programmation, de sorte que tout étudiant
                        puisse en comprendre les principes, la philosophie et puisse ensuite les appliquer dans le
                        langage de son choix. De plus Scala sera utilisé comme langage d’exemple pour le cours.
                        Au long de ce cours nous aborderons de nombreux aspects du langage Scala, notamment le système
                        de type, le polymorphisme, la complémentarité entre le paradigme objet et le paradigme
                        fonctionnel et nous appliquerons ces concepts sur un projet de programmation de type CLI, de
                        sorte que tout étudiant ayant suivi ce cours puisse être à même de monter en compétence sur un
                        projet professionnel.
Description détaillée : 1. Introduction à la programmation fonctionnelle
                           - concepts : fonction, pureté, composition, récursivité
					    2. Introduction à Scala
					       - concepts : présentation fonctionnelle de Scala, présentation objet de Scala
					    3. Types et polymorphisme
					       - concepts : formes de typage, generics, typeclass, sous-typage, types avancés
					    4. Gestion des effets en programmation fonctionnelle
					       - concepts : effets, puretés, monades (Future, Either, Try, Option, List)
					    5. Manipulations et cas pratiques
Modalité d’évaluation : - CC - ÉCRIT
                        - Partiel - Projet avec soutenance
 Exemple d’évaluation : Construction d’une application en Scala en suivant les préceptes de programmation fonctionnelle
                        et de modélisation abordés pendant le cours (pilotage d’une tondeuse à gazon automatique,
                        destinée aux surfaces rectangulaires).
-->

				<section aria-description="Programmation fonctionnelle avec Scala">
					<h1>Programmation fonctionnelle avec Scala</h1>
				</section>

				<section aria-description="Introduction">
					<section>
						<h2>Tour de table &#128064;</h2>
					</section>

					<section>
						<h3>Enseignant</h3>
						<h4>Sébastian Le Merdy</h4>
						<p><strong>19 ans</strong> d’expérience professionnelle<br>dans le développement</p>
					</section>

					<section>
						<p>ESN &#128558;</p>
						<dl>
							<dt>
							  <img src="img/logo-xebia.png" alt="Xebia" style="width: 5em">
							</dt>
							<dd>
								<img src="img/logo-societe-generale.png" alt="Société Générale" style="width: 2em">
								<img src="img/logo-colissimo.png" alt="Colissimo" style="width: 2em">
								<img src="img/logo-libon.png" alt="Libon" style="width: 2em">
								<img src="img/logo-vidal.png" alt="Vidal" style="width: 2em">
								<img src="img/logo-michelin.png" alt="Michelin" style="width: 2em">
								<img src="img/logo-bisam.png" alt="Bisam" style="width: 3em">
							</dd>
							<dt>
								<img src="img/logo-elosi.png" alt="Elosi" style="width: 3em">
							</dt>
							<dd>
								<img src="img/logo-rsi.png" alt="Rsi" style="width: 3em">
								<img src="img/logo-gmf.png" alt="GMF" style="width: 1em">
							</dd>
						</dl>
					</section>

					<section>
						<p>Plus récemment dans un organisme de paiement</p>
						<p>
							<img src="img/logo-nickel.png" alt="Nickel" style="width: 6em">
						</p>
					</section>

					<section>
						<p>Actuellement chez un <strong>éditeur</strong> SaaS<br><em>dans la data</em></p>
						<p>
							<img src="img/logo-zeenea.png" alt="Zeenea" style="width: 10em">
						</p>
					</section>

					<section>
						<p>Principalement autour des langages JVM</p>
						<p>
							<img src="img/logo-java.png" alt="Java">
							<img src="img/logo-scala.png" alt="Scala">
						</p>
					</section>

					<section>
						<h3>Et vous ?</h3>
						<p>Quelle expérience avec des langages fonctionnels ?</p>
						<ul>
							<li>OCaml</li>
							<li>Haskell</li>
							<li>F#</li>
							<li>C</li>
						</ul>
					</section>

					<section>
						<p>Connaissez-vous les mots-clés ?</p>
						<ul>
							<li>fonctions pures</li>
							<li>récursivité</li>
							<li>effets de bord</li>
							<li>monades</li>
						</ul>
					</section>

					<section>
						<p>Mais rentrons dans le vif du sujet</p>
						<p>FP&#8230;</p>
					</section>
				</section>

				<section aria-description="1. Introduction à la programmation fonctionnelle">
					<h2>Introduction à la programmation fonctionnelle</h2>
				</section>

				<section aria-description="1.1 Fonction">
					<section>
					    <h3>Fonction</h3>
					</section>

					<section>
						<h4>Définition mathématique</h4>
						<p class="section">
							<code>E &#8594; F</code><br>
							<code>x &#8614; f(x)</code>
						</p>
					</section>

					<section>
						<p>
							Il s’agit d’une <strong>transformation</strong><br>
							d’une valeur appartement à l’ensemble de départ<br>
							vers une valeur appartenant à l’ensemble d’arrivée.
						</p>
					</section>

					<section data-transition="none">
						<h4>Exemple : des tâches et leur statut</h4>
						<img src="img/tasks-01.png" alt="des statuts de tâche">
					</section>

					<section data-transition="none">
						<h4>Des transitions entre tâches</h4>
						<img src="img/tasks-02.png" alt="des statuts de tâche et des transitions">
					</section>

					<section data-transition="none">
						<h4>Ensembles de départ et d’arrivée</h4>
						<img src="img/tasks-03.png" alt="ensemble de départ et ensemble d’arrivée de findTransitions()">
					</section>

					<section>
						<pre><code class="language-scala">enum TaskStatus:
  case Created, Started, InReview, Done</code></pre>
						<pre class="fragment"><code class="language-scala">enum TaskTransition:
  case Start, Finish, RequestChange, Accept</code></pre>
						<pre class="fragment"><code class="language-scala">def findTransitions: TaskStatus => Seq[TaskTransition] =
  case Created  => Seq(Start)
  case Started  => Seq(Finish)
  case InReview => Seq(RequestChange, Accept)
  case Done     => Seq()</code></pre>
					</section>

					<section>
						<h4>Règle tirée de la réalité</h4>
						<p>Toujours chercher à diminuer la taille des ensembles de départ et d’arrivée permet de</p>
						<ol>
							<li>Simplifier le code et la lisibilité</li>
							<li>Éviter les bugs</li>
							<li>Éviter les attaques</li>
							<li>Ne pas implémenter des cas qui ne serviront jamais</li>
						</ol>
					</section>

					<section data-background="#336699" data-background-gradient="radial-gradient(#336699, #003366)">
						<h4>Travail pratique</h4>
						<p>Mettre en place un environnement de développement pour écrire sa première fonction en Scala</p>
						<ol>
							<li>Télécharger <a href="https://www.jetbrains.com/fr-fr/idea/download">IntelliJ IDEA Community Edition</a></li>
							<li>Installer IntelliJ IDEA Community Edition</li>
							<li>Installer le plugin Scala</li>
							<li>Générer un nouveau projet</li>
						</ol>
					</section>

					<section data-background="#336699" data-background-gradient="radial-gradient(#336699, #003366)">
						<h4>Travail pratique</h4>
						<img src="img/new-project.png" alt="Nouveau projet avec IntelliJ IDEA Community Edition" style="max-width: 75%">
					</section>

					<section data-background="#336699" data-background-gradient="radial-gradient(#336699, #003366)">
						<h4>Travail pratique</h4>
						<img src="img/new-project-firstFunction.png" alt="Résultat de l’exécution de notre première fonction" style="max-width: 70%">
					</section>

					<section>
						<h4>Caractéristiques d’une fonction</h4>
						<ul>
							<li>totale</li>
							<li>déterministe</li>
							<li>sans effet de bord</li>
						</ul>
					</section>
				</section>

				<section aria-description="1.2 Pureté">
					<section>
						<h3>Pureté</h3>
					</section>

					<section>
                        <pre><code class="language-scala">def sayHello(niceMessage: String): Unit =
  println(s"Hello $niceMessage")</code></pre>

                        <pre class="fragment"><code class="language-scala">sayHello("world!")</code></pre>

						<pre class="fragment"><code class="language-plaintext">Hello world!</code></pre>
					</section>

					<section>
                        <pre><code class="language-scala">def dice(): Int =
  Random.nextInt(6) + 1</code></pre>

                        <pre class="fragment"><code class="language-scala">dice()
val res0: Int = 5</code></pre>

						<pre class="fragment"><code class="language-scala">dice()
val res1: Int = 3</code></pre>
					</section>

					<section>
                        <pre><code class="language-scala">def nowPlus(days: Long): Instant =
  Instant.now().plus(days, ChronoUnit.DAYS)</code></pre>

                        <pre class="fragment"><code class="language-scala">nowPlus(3)
val res0: java.time.Instant = 2024-03-05T18:55:34.125784Z</code></pre>

						<pre class="fragment"><code class="language-scala">nowPlus(5)
val res1: java.time.Instant = 2024-03-07T18:55:34.215660Z</code></pre>
					</section>

					<section>
                        <pre><code class="language-scala">def saveArticle(id: UUID, content: String, author: Author)(
    database: Database
): Boolean =
  database.executeQuery(
    """INSERT INTO Article(id, content, author_name, author_email)
      |VALUES (:id, :content, :author_name, :author_email);
      |""".stripMargin,
    "id" -> id,
    "content" -> content,
    "author_name" -> author.name,
    "author_email" -> author.email
  )</code></pre>

						<pre class="fragment"><code class="language-scala">saveArticle(
    UUID.fromString("0d975fff-44dc-4110-b21a-1f31148969b8"),
    "&lt;p&gt;Great content&lt;/p&gt;",
    Author("Sébastian", "seb@example.com")
  )(postgresql)
val res0: Boolean = true</code></pre>
					</section>

					<section>
						<p>Toutes ces fonctions sont <em>impures</em> car :</p>
						<ul>
							<li>Deux appels successifs ne produisent pas la même valeur en retour ;</li>
							<li>Elles créent des effets de bord.</li>
						</ul>
					</section>

					<section>
						<h4>Pourquoi les fonctions pures sont-elles intéressantes ?</h4>
						<ul>
							<li class="fragment">transparence référentielle</li>
							<li class="fragment">immuabilité
								<ul>
									<li>des paramètres en entrée</li>
									<li>une valeur produite en retour</li>
								</ul>
						</ul>
						<p class="fragment">Permet donc des <strong>optimisations massivement parallélisables</strong></p>
					</section>

					<section data-background="#336699" data-background-gradient="radial-gradient(#336699, #003366)">
						<h4>Travail pratique</h4>
						<p>Écrire une fonction pure qui débarrasse les emails suivant du bruit:</p>
						<pre>"kai@example.com
sacha@example.net"
"cruz@example.org"
  noam@example.com    </pre>
					</section>

					<section data-background="#336699" data-background-gradient="radial-gradient(#336699, #003366)">
						<div>
							Utiliser un framework de test unitaire<br>
							<pre><code class="language-scala">libraryDependencies +=
    "org.scalameta" %% "munit" % "0.7.29" % Test</code></pre>
							<pre><code class="language-scala">import munit.FunSuite

class EmailCleaner extends FunSuite:

  private def clean(notCleanedEmail: String): String = ???

  test("emailCleaner"):
    assertEquals(
      obtained = clean(""""kai@example.com"""),
      expected = "kai@example.com"
    )</code></pre>
						</div>
					</section>

					<section data-background="#339966" data-background-gradient="radial-gradient(#339966, #003333)">
						<h3>Les tests unitaires</h3>
						<pre><code class="language-scala">import EmailCleaner.clean
import munit.FunSuite

class EmailCleanerSuite extends FunSuite:
  test("remove starting quote"):
    assertEquals(clean(""""kai@example.com"""),
                         "kai@example.com")
  test("remove trailing quote"):
    assertEquals(clean("""sacha@example.net""""),
                         "sacha@example.net")
  test("remove starting and trailing quote"):
    assertEquals(clean(""""cruz@example.org""""),
                         "cruz@example.org")
  test("remove starting and trailing spaces"):
    assertEquals(clean("""  noam@example.com    """),
                         "noam@example.com")</code></pre>
					</section>

					<section data-background="#339966" data-background-gradient="radial-gradient(#339966, #003333)">
						<h3>L’implémentation</h3>
						<pre><code class="language-scala">object EmailCleaner:

  private val        startWithQuote = """^"(.+)""".r
  private val         endsWithQuote = """(.+)"$""".r
  private val  startAndEndWithQuote = """^"(.+)"$""".r
  private val startAndEndWithSpaces = """^\s+(.*?)\s+$""".r

  def clean(notCleanedEmail: String): String =
    notCleanedEmail match
      case startAndEndWithQuote(email) => email
      case startWithQuote(email) => email
      case endsWithQuote(email) => email
      case startAndEndWithSpaces(email) => email
      case _ => notCleanedEmail</code></pre>
					</section>

					<section>
						<p>Les fonctions pures sont importantes : ce sont les blocs de base de la programmation fonctionnelle.</p>
						<p class="fragment">Mais comment aller plus loin et finir par écrire de vrais programmes ?</p>
					</section>
				</section>

				<section aria-description="1.3 Composition">
					<section>
						<h3>Composition</h3>
					</section>

					<section>
						<h4>Définition mathématique</h4>
						<p><code>f &#8728; g</code></p>
						<p><code>f(g(x))</code></p>
					</section>

					<section>
						<h4>D’un point de vue génie logiciel</h4>
						<p>Il s’agit d’un moyen de garantir</p>
						<ol>
							<li>la ré-utilisabilité du code</li>
							<li>le bon niveau d’abstraction</li>
							<li>la lisibilité</li>
						</ol>
					</section>

					<section>
						<pre><code class="language-scala">case class User(name: String, age: Int)</code></pre>

						<pre class="fragment"><code class="language-scala">enum Category:
  case Young, Adult, Old</code></pre>

						<pre class="fragment"><code class="language-scala">val categoryByMaxAges: Map[Int, Category] =
  Map(
    24 -> Category.Young,
    64 -> Category.Adult,
    Integer.MAX_VALUE -> Category.Old
  )</code></pre>

						<pre class="fragment"><code class="language-scala">val discountByCategories: Map[Category, Int] =
  Map(
    Category.Young -> 25,
    Category.Adult -> 0,
    Category.Old -> 35
  )</code></pre>
					</section>

					<section>
						<pre><code class="language-scala">def computePrice(
    user: User,
    categories: Map[Int, Category],
    price: Long,
    discounts: Map[Category, Int]
): Long = price - price * discounts(
  categories
    .filter { case (maxAge, category) => maxAge >= user.age }
    .minBy { case (maxAge, category) => maxAge }
    ._2
) / 100</code></pre>

						<pre class="fragment"><code class="language-scala">computePrice(          computePrice(          computePrice(
  User("Emma", 16),      User("Nicolas", 41),   User("Martine", 67),
  categoryByMaxAges,     categoryByMaxAges,     categoryByMaxAges,
  price = 1999,          price = 5500,          price = 4999,
  discountByCategories   discountByCategories   discountByCategories
)                      )                      )
val res0: Long = 1500  val res1: Long = 5500  val res2: Long = 3250</code></pre>
					</section>

					<section>
						<h3>Décomposons</h3>
					</section>

					<section>
						<pre><code class="language-scala">
def computePrice(
    user: User,
    categories: Map[Int, Category],
    price: Long,
    discounts: Map[Category, Int]
): Long =
  computePrice(
    price,
    computeDiscount(user, categories, discounts)
  )
						</code></pre>
					</section>

					<section>
						<pre><code class="language-scala">
def computePrice(price: Long, discount: Long): Long =
  price - price * discount / 100
						</code></pre>
					</section>

					<section>
						<pre><code class="language-scala">
def computeDiscount(
    user: User,
    categories: Map[Int, Category],
    discounts: Map[Category, Int]
): Long = discounts(findCategory(user, categories))
						</code></pre>
					</section>

					<section>
						<pre><code class="language-scala">
def findCategory(
    user: User,
    categories: Map[Int, Category]
): Category =
  val (_, category) = categories
    .filter { case (maxAge, category) => maxAge >= user.age }
    .minBy { case (maxAge, category) => maxAge }
  category
						</code></pre>
					</section>

					<section data-background="#336699" data-background-gradient="radial-gradient(#336699, #003366)">
						<h4>Travail pratique</h4>
						<ol>
							<li>Écrire deux fonctions pures :
								<ol>
									<li><code>times2</code> qui multiplie un <code>Int</code> par 2</li>
									<li><code>addOne</code> qui ajoute 1 au <code>Int</code> passé en paramètre</li>
								</ol>
							</li>
							<li class="fragment">Composer ces deux fonctions pour obtenir une fonction qui multiplie un <code>Int</code> par 2 puis ajoute 1.</li>
						</ol>
					</section>

					<section data-background="#339966" data-background-gradient="radial-gradient(#339966, #003333)">
						<h4>Corrigé</h4>
						<pre><code>object Composition:

  def times2(value: Int): Int = value * 2

  def addOne(value: Int): Int = value + 1

  def times2PlusOne(value: Int): Int = addOne(times2(value))

  @main def compositionMain(): Unit =
    println(times2PlusOne(5)) // 11</code></pre>
					</section>

					<section>
						<h4>Les fonctions : ces citoyens de premier ordre</h4>
					</section>

					<section>
						<p>Une fonction est considérée comme un type de données comme les autres.</p>
						<ul>
							<li class="fragment">peut-être passée en argument d’une autre fonction</li>
						</ul>
					</section>

					<section>
						<pre><code class="language-scala">def logBeforeAndAfter(message: String, task: () => Unit): Unit =
  println(s"before $message")
  task()
  println(s" after $message")</code></pre>

						<pre class="fragment"><code class="language-scala">logBeforeAndAfter("hello", () => { println("Hello World!") })</code></pre>

						<pre class="fragment"><code class="language-plaintext">before hello
Hello World!
 after hello</code></pre>
					</section>

					<section>
						<pre><code class="language-scala">def logBeforeAndAfterResult(
    message: String,
    computeResult: String => Long
): Unit =
  println(s"before $message")
  println(s"result ${computeResult(message)}")
  println(s" after $message")</code></pre>

						<pre class="fragment"><code class="language-scala">logBeforeAndAfterResult("hello", message => message.length)</code></pre>
						<pre class="fragment"><code class="language-plaintext">before hello
result 5
 after hello</code></pre>
					</section>

					<section>
						<p>Une fonction est considérée comme un type de données comme les autres.</p>
						<ul>
							<li>peut-être passée en argument d’une autre fonction</li>
							<li class="fragment">peut-être retournée par une autre fonction</li>
						</ul>
					</section>

					<section>
						<pre><code class="language-scala">def operationToCompute(operation: String): (Long, Long) => Long =
  operation match
    case "add"      => (left, right) => left + right
    case "subtract" => (left, right) => left - right
    case "multiply" => (left, right) => left * right
    case _          => (left, right) => Long.MinValue</code></pre>

						<pre class="fragment"><code class="language-scala">operationToCompute("add"     )(3, 2)
val res0: Long = 5</code></pre>

						<pre class="fragment"><code class="language-scala">operationToCompute("subtract")(3, 2)
val res1: Long = 1</code></pre>

						<pre class="fragment"><code class="language-scala">operationToCompute("multiply")(3, 2)
val res2: Long = 6</code></pre>

						<pre class="fragment"><code class="language-scala">operationToCompute("divide"  )(3, 2)
val res3: Long = -9223372036854775808</code></pre>
					</section>

					<section data-background="#336699" data-background-gradient="radial-gradient(#336699, #003366)">
						<h4>Travail pratique</h4>
						<p>Utiliser <code>compose</code> et/ou <code>andThen</code> pour composer <code>times2</code> et <code>addOne</code></p>
					</section>

					<section data-background="#339966" data-background-gradient="radial-gradient(#339966, #003333)">
						<h4>Corrigé</h4>
						<pre><code class="language-scala">object Composition:

  def times2(value: Int): Int = value * 2

  def addOne(value: Int): Int = value + 1

  def times2PlusOne(value: Int): Int = addOne(times2(value))
  def withCompose(value: Int): Int   = addOne.compose(times2)(value)
  def withAndThen(value: Int): Int   = times2.andThen(addOne)(value)

  @main def compositionMain(): Unit =
    println(times2PlusOne(5)) // 11
    println(withCompose(5))   // 11
    println(withAndThen(5))   // 11</code></pre>
					</section>
				</section>

				<section aria-description="1.4 Récursivité">
					<section>
						<h3>Récursivité</h3>
					</section>

					<section>
						<p>La possibilité pour une fonction de se rappeler elle-même. Permet de traiter :</p>
						<ul>
							<li>une structure de données elle-même récursive</li>
							<li>une collection</li>
						</ul>
					</section>

					<section>
						<h4>Implémentation</h4>
						<ol>
							<li>trouver une ou plusieurs conditions d’arrêt</li>
							<li>se rappeler soi-même avec des données transformées</li>
						</ol>
					</section>

					<section>
						<h4>Récursion terminale</h4>
						<p>L’appel récursif est la dernière évaluation dans l’implémentation de la fonction</p>
						<p>Permet d’éviter des épuisements de la pile d’exécution (aka StackOverflow®)</p>
					</section>

					<section>
						<h4>Exemple : lire un flux</h4>
						<pre><code class="language-scala">val input = """34
              |84
              |12
              |
              |32
              |28
              |9
              |7""".stripMargin</code></pre>
						<pre class="fragment"><code class="language-scala">@tailrec
def sums(
    input: List[String],
    acc: Seq[Long] = Vector.empty,
    sum: Long = 0
): Seq[Long] =
  input match
    case Nil        => acc :+ sum
    case "" :: tail => sums(tail, acc :+ sum)
    case n :: tail  => sums(tail, acc, sum + n.toLong)</code></pre>
						<pre class="fragment"><code class="language-scala">sums(input.linesIterator.toList)
val res0: Seq[Long] = Vector(130, 76)</code></pre>
					</section>

					<section data-background="#336699" data-background-gradient="radial-gradient(#336699, #003366)">
						<h4>Travail pratique</h4>
						<p>
							Calculer la somme<br>
							du premier et du dernier chiffre<br>
							de chacune des lignes<br>
							en n’utilisant que des fonctions récursives</p>
						<pre>two1nine
eightwothree
abcone2threexyz
xtwone3four
4nineeightseven2
zoneight234
7pqrstsixteen
</pre>
					</section>

					<section data-transition="none" data-background="#336699" data-background-gradient="radial-gradient(#336699, #003366)">
						<h4>Travail pratique</h4>
						<p>
							Calculer la somme<br>
							du premier et du dernier chiffre<br>
							de chacune des lignes<br>
							en n’utilisant que des fonctions récursives</p>
						<pre>two1nine         -> 219         ->  29
eightwothree     -> 8wo3        ->  83
abcone2threexyz  -> abc123xyz   ->  13
xtwone3four      -> x2ne34      ->  24
4nineeightseven2 -> 49872       ->  42
zoneight234      -> z1ight234   ->  14
7pqrstsixteen    -> 7pqrst6teen ->  76
                                   281</pre>
					</section>

					<section data-background="#339966" data-background-gradient="radial-gradient(#339966, #003333)">
						<h4>Corrigé de la première fonction: test unitaire</h4>
						<pre><code class="language-scala">import SumAll.toNumber
import munit.FunSuite

class SumAllSuite extends FunSuite:

  test("toNumber"):
    assertEquals(toNumber("two1nine"),         "219")
    assertEquals(toNumber("eightwothree"),     "8wo3")
    assertEquals(toNumber("abcone2threexyz"),  "abc123xyz")
    assertEquals(toNumber("xtwone3four"),      "x2ne34")
    assertEquals(toNumber("4nineeightseven2"), "49872")
    assertEquals(toNumber("zoneight234"),      "z1ight234")
    assertEquals(toNumber("7pqrstsixteen"),    "7pqrst6teen")</code></pre>
					</section>

					<section data-background="#339966" data-background-gradient="radial-gradient(#339966, #003333)">
						<h4>Corrigé de la première fonction: implémentation</h4>
						<pre><code class="language-scala">object SumAll:

  def toNumber(value: String): String = value match
    case ""                         => "" // terminating scenario
    case s if s.startsWith("one")   => "1" + toNumber(s.drop(3))
    case s if s.startsWith("two")   => "2" + toNumber(s.drop(3))
    case s if s.startsWith("three") => "3" + toNumber(s.drop(5))
    case s if s.startsWith("four")  => "4" + toNumber(s.drop(4))
    case s if s.startsWith("five")  => "5" + toNumber(s.drop(4))
    case s if s.startsWith("six")   => "6" + toNumber(s.drop(3))
    case s if s.startsWith("seven") => "7" + toNumber(s.drop(5))
    case s if s.startsWith("eight") => "8" + toNumber(s.drop(5))
    case s if s.startsWith("nine")  => "9" + toNumber(s.drop(4))
    case s                          => s.take(1) + toNumber(s.drop(1))</code></pre>
					</section>

					<section data-background="#339966" data-background-gradient="radial-gradient(#339966, #003333)">
						<h4>Corrigé de la seconde fonction: test unitaire</h4>
						<pre><code class="language-scala">import SumAll.{firstAndLast, toNumber}
import munit.FunSuite

class SumAllSuite extends FunSuite:

  test("firstAndLastNumber"):
    assertEquals(firstAndLastNumber("219"),         "29")
    assertEquals(firstAndLastNumber("8wo3"),        "83")
    assertEquals(firstAndLastNumber("abc123xyz"),   "13")
    assertEquals(firstAndLastNumber("x2ne34"),      "24")
    assertEquals(firstAndLastNumber("49872"),       "42")
    assertEquals(firstAndLastNumber("z1ight234"),   "14")
    assertEquals(firstAndLastNumber("7pqrst6teen"), "76")

  test("toNumber"):
    () // …</code></pre></section>

					<section data-background="#339966" data-background-gradient="radial-gradient(#339966, #003333)">
						<h4>Corrigé de la seconde fonction: implémentation</h4>
						<pre><code class="language-scala">import scala.util.Try

object SumAll:

  def first(value: String): String = value match
    case ""                                  => ""
    case s if Try(s.take(1).toInt).isSuccess => s.take(1)
    case s                                   => first(s.drop(1))

  def last(value: String): String = first(value.reverse)

  def firstAndLastNumber(value: String): String =
    first(value) + last(value)

  def toNumber(value: String): String = ??? // …</code></pre>
					</section>

					<section data-background="#339966" data-background-gradient="radial-gradient(#339966, #003333)">
						<h4>Corrigé de la fonction principale: test unitaire</h4>
						<pre><code class="language-scala">import SumAll.{firstAndLastNumber, sumAll, toNumber}
import munit.FunSuite

class SumAllSuite extends FunSuite:

  test("sumAll"):
    assertEquals(sumAll("""two1nine
                          |eightwothree
                          |abcone2threexyz
                          |xtwone3four
                          |4nineeightseven2
                          |zoneight234
                          |7pqrstsixteen""".stripMargin), 281)

  test("firstAndLastNumber"):
	() // …

  test("toNumber"):
    () // …</code></pre>
					</section>

					<section data-background="#339966" data-background-gradient="radial-gradient(#339966, #003333)">
						<h4>Corrigé de la seconde fonction: implémentation</h4>
						<pre><code class="language-scala">import scala.jdk.StreamConverters.*
import scala.util.Try

object SumAll:

  def firstAndLastNumber(value: String): String = ??? // …

  def toNumber(value: String): String = ??? // …

  def sumAll(values: String): Int =
    values.lines().toScala(Vector)
      .map(toNumber)
      .map(firstAndLastNumber)
      .map(_.toInt)
      .sum</code></pre>
					</section>
				</section>

				<section aria-description="2. Introduction à Scala">
					<h2>Introduction à Scala</h2>
				</section>

				<section aria-description="2.1 Présentation fonctionnelle de Scala">
					<section>
						<h2>Présentation fonctionnelle de Scala</h2>
					</section>

					<section>
						<h3>Modéliser la donnée</h3>
						<p>ADT - Algebraic Data Types</p>
						<ul>
							<li class="fragment">
								Sum types : énumérations
								<pre><code class="language-scala">enum TaskStatus:
  case Created, Started,
    InReview, Done</code></pre>
							</li>
							<li class="fragment">
								Product types : case classes
								<pre><code class="language-scala">case class Task(
    name: String,
    status: TaskStatus
)</code></pre>
							</li>
						</ul>
					</section>

					<section>
						<h3>Décrire et appliquer des traitements</h3>
						<p>Écrire des fonctions</p>
						<pre class="fragment"><code class="language-scala">def findTransitions: TaskStatus => Seq[TaskTransition] =
  case Created  => Seq(Start)
  case Started  => Seq(Finish)
  case InReview => Seq(RequestChange, Accept)
  case Done     => Seq()</code></pre>
						<pre class="fragment"><code class="language-scala">def findTransitions(status: TaskStatus): Seq[TaskTransition] =
  status match
    case Created  => Seq(Start)
    case Started  => Seq(Finish)
    case InReview => Seq(RequestChange, Accept)
    case Done     => Seq()</code></pre>
					</section>

					<section>
						<h3>Notes sur les fonctions</h3>
						<p>
							Avec les ADT, on force les fonctions à être pures, car ces structures de données sont
							immuables.
						</p>
					</section>

					<section>
						<h3>Comment organiser le code ?</h3>
						<ul>
							<li>des méthodes dans les objets compagnions</li>
							<li>style modulaire avec des interfaces et des implémentations</li>
							<li>des méthodes dans les types de données immuables</li>
							<li>des méthodes d’extension pour ajouter les fonctionnalités aux types de données</li>
						</ul>
					</section>

					<section data-background="#336699" data-background-gradient="radial-gradient(#336699, #003366)">
						<h3>Exercice Pratique</h3>
						<p>Matrice de lumières : calcul de la consommation énergétique</p>
						<dl>
							<dt><code>turn on 0,0 through 999,999</code></dt>
							<dd>allume (ou laisse allumées) toutes les lumières</dd>
							<dt><code>toggle 0,0 through 999,0</code></dt>
							<dd>
								bascule la première ligne de 1000 lumières, éteignant celles qui étaient allumées et
								allumant celles qui étaient éteintes.
							</dd>
							<dt><code>turn off 499,499 through 500,500</code></dt>
							<dd>éteint (ou laisse éteintes) les quatres lumières du milieu.</dd>
						</dl>
					</section>

					<section data-background="#336699" data-background-gradient="radial-gradient(#336699, #003366)">
						<h3>Exercice Pratique : instructions</h3>
						<pre><code>turn on 887,9 through 959,629
turn on 454,398 through 844,448
turn off 539,243 through 559,965
turn off 370,819 through 676,868
turn off 145,40 through 370,997
turn off 301,3 through 808,453
turn on 351,678 through 951,908
toggle 720,196 through 897,994
toggle 831,394 through 904,860</code></pre>
						<p>Combien de lumières sont-elles allumées ?</p>
					</section>

					<section data-background="#339966" data-background-gradient="radial-gradient(#339966, #003333)">
						<h4>Corrigé : test unitaire</h4>
						<pre><code class="language-scala">import ChristmasLights.countLitLights

class ChristmasLightsSuite extends munit.FunSuite:
  test("count lit lights after instructions"):
    val program = """turn on 887,9 through 959,629
                    |turn on 454,398 through 844,448
                    |turn off 539,243 through 559,965
                    |turn off 370,819 through 676,868
                    |turn off 145,40 through 370,997
                    |turn off 301,3 through 808,453
                    |turn on 351,678 through 951,908
                    |toggle 720,196 through 897,994
                    |toggle 831,394 through 904,860""".stripMargin
    val count = countLitLights(program)
    assertEquals(count, 230_022)</code></pre>
					</section>

					<section data-background="#339966" data-background-gradient="radial-gradient(#339966, #003333)">
						<h4>Corrigé : ADTs</h4>
						<pre><code class="language-scala">object ChristmasLights:

  case class Coordinates(x: Int, y: Int)

  enum Instruction:
    case ON(corner1: Coordinates, corner2: Coordinates)
    case OFF(corner1: Coordinates, corner2: Coordinates)
    case TOGGLE(corner1: Coordinates, corner2: Coordinates)</code></pre>
					</section>

					<section data-background="#339966" data-background-gradient="radial-gradient(#339966, #003333)">
						<h4>Corrigé : parsing</h4>
						<pre><code class="language-scala">import scala.util.matching.Regex

object ChristmasLights:

  object Instruction:
    val onRegex: Regex =
      """turn on (\d+),(\d+) through (\d+),(\d+)""".r
    val offRegex: Regex = """turn off (\d+),(\d+) through (\d+),(\d+)""".r
    val toggleRegex: Regex = """toggle (\d+),(\d+) through (\d+),(\d+)""".r
    def apply(line: String): Instruction = line match
      case onRegex(x1, y1, x2, y2) =>
        ON(Coordinates(x1.toInt, y1.toInt),
           Coordinates(x2.toInt, y2.toInt))
      case offRegex(x1, y1, x2, y2) => OFF(Coordinates(x1.toInt, y1.toInt), Coordinates(x2.toInt, y2.toInt))
      case toggleRegex(x1, y1, x2, y2) => TOGGLE(Coordinates(x1.toInt, y1.toInt), Coordinates(x2.toInt, y2.toInt))</code></pre>
					</section>

					<section data-background="#339966" data-background-gradient="radial-gradient(#339966, #003333)">
						<h4>Corrigé : application des instruction et somme</h4>
						<pre><code class="language-scala">import ChristmasLights.Instruction.{OFF, ON, TOGGLE}
import scala.jdk.StreamConverters.*

object ChristmasLights:
  def applyToRectangle[T](c1: Coordinates, c2: Coordinates, effect: (x: Int, y: Int) => T): Seq[T] =
    Range(c1.y, c2.y + 1).flatMap(y => Range(c1.x, c2.x + 1)
                         .map(x => effect(x, y)))</code></pre>
						<pre><code class="language-scala">  def countLitLights(program: String): Int =
    val lights = applyToRectangle(Coordinates(0, 0), Coordinates(999, 999), (_, _) => false).toBuffer
    program.lines().toScala(Vector).map(Instruction.apply)
                                   .foreach:
	  case ON(c1, c2)     => applyToRectangle(c1, c2,
        (x, y) => lights.update(y * 1000 + x, true))
	  case OFF(c1, c2)    => applyToRectangle(c1, c2,
        (x, y) => lights.update(y * 1000 + x, false))
	  case TOGGLE(c1, c2) => applyToRectangle(c1, c2,
        (x, y) => lights.update(y * 1000 + x, !lights(y * 1000 + x)))
    lights.count(lightIsOn => lightIsOn)</code></pre>
					</section>
				</section>

				<section aria-description="2.2 Présentation objet de Scala">
					<section><h2>Présentation objet de Scala</h2></section>

					<section>
						<h2>Différents types d’outils</h2>
						<ul>
							<li class="fragment">Traits</li>
						</ul>
					</section>

					<section>
						<p>Un trait permet de définir une interface</p>
						<p>C’est une liste de méthodes abstraites</p>
						<pre class="fragment"><code class="language-scala">trait AccountContract:
  def deposit(amount: Int): Unit
  def withdraw(amount: Int): Unit
  def printStatement(): String</code></pre>
					</section>

					<section>
						<p>Il peut également définir des membres abstraits</p>
						<ul>
							<li>méthodes abstraites : <code>def m(): T</code></li>
							<li class="fragment">définitions de valeurs abstraites : <code>val x: T</code></li>
							<li class="fragment">types abstraits : <code>type T</code></li>
							<li class="fragment"><em>given</em> abstraits : <code>given t: T</code></li>
						</ul>
					</section>

					<section>
						<p>Ces traits peuvent ensuite être <em>mixés dans</em></p>
						<p>— <em>Mixin Composition</em> —</p>
						<p>des implémentations concrètes</p>
					</section>

					<section>
						<pre><code class="language-scala">class Account(private val clock: Clock) extends AccountContract:
  private val transactions = mutable.ListBuffer[Transaction]()
  private var balance = 0

  override def deposit(amount: Int): Unit =
    balance += amount
    val now = clock.instant().atZone(UTC).toLocalDate
    transactions.append(Transaction(now, amount, balance))
  override def withdraw(amount: Int): Unit =
    balance -= amount
    val now = clock.instant().atZone(UTC).toLocalDate
    transactions.append(Transaction(now, -amount, balance))
  override def printStatement(): String = transactions
    .map(_.toString)
    .mkString("Date       Amount Balance\n", "\n", "")</code></pre>
					</section>

					<section>
						<p>
							Que se passe-t-il dans le cas où on <em>mixin</em> plusieurs traits avec des déclarations
							abstraites identiques ?
						</p>
						<img src="img/oop-class-diagram-01.png" alt="Diagramme de classe">
						<!--
@startuml
abstract class AccountContract << (T,#A492DE) >> {
  {method} {abstract} +deposit(amount: Int): Unit
  {method} {abstract} +withdraw(amount: Int): Unit
  {method} {abstract} +printStatement(): String
}

abstract class Printable << (T,#A492DE) >> {
  {method} {abstract} +printStatement(): String
}

class Account {
  {method} +deposit(amount: Int): Unit
  {method} +withdraw(amount: Int): Unit
  {method} +printStatement(): String
}

AccountContract <|-- Account
Printable <|-- Account
@enduml
						-->
						<p class="fragment">&#9989; Ça compile &#128524;</p>
					</section>

					<section>
						<p>
							Mais dans le cas d’une implémentation par défaut dans les deux traits ?
						</p>
						<img src="img/oop-class-diagram-02.png" alt="Diagramme de classe avec implémentations par défaut">
						<!--
@startuml
abstract class AccountContract << (T,#A492DE) >> {
  {method} {abstract} +deposit(amount: Int): Unit
  {method} {abstract} +withdraw(amount: Int): Unit
  {method} +printStatement(): String = "account"
}

abstract class Printable << (T,#A492DE) >> {
  {method} +printStatement(): String = "printable"
}

class Account {
  {method} +deposit(amount: Int): Unit
  {method} +withdraw(amount: Int): Unit
}

AccountContract <|-- Account
Printable <|-- Account
@enduml

rsvg-convert class-diagram-02.svg > class-diagram-02.png
						-->
						<div class="fragment">
							<p>&#10062; Ça ne compile pas &#128524;</p>
							<pre><code class="language-diff">error overriding method printStatement in class Account inherits
  conflicting members:
    method printStatement in trait AccountContract
and method printStatement in trait Printable
(Note: this can be resolved by declaring an override in class
 Account.)</code></pre>
						</div>
					</section>

					<section>
						<h2>Différents types d’outils</h2>
						<ul>
							<li>Traits</li>
							<li class="fragment">Classes</li>
						</ul>
					</section>

					<section>
						<p>Implémentations concrètes, comme en C++ ou en Java.</p>
						<pre class="fragment"><code class="language-scala" data-line-numbers="1-2|3-6|7-10|12">class Account(private val clock: Clock)
    extends AccountContract:

  private val transactions = mutable.ListBuffer[Transaction]()
  private var balance = 0

  override def deposit(amount: Int): Unit =
    balance += amount
    val now = clock.instant().atZone(UTC).toLocalDate
    transactions.append(Transaction(now, amount, balance))

end Account</code></pre>
					</section>

					<section>
						<p>Pour s’en servir, on a besoin de l’<em>instancier</em>.</p>
						<pre class="fragment"><code class="language-scala" data-line-numbers="1|3">val savings = Account(Clock.systemDefaultZone())

savings.deposit(20000)</code></pre>
					</section>

					<section>
						<h3>Note à propos de la visibilité</h3>
						<p>Toutes les définitions d’une classe sont <code>public</code> par défaut.</p>
						<p>
							Il faut les rendre <code>private</code> ou <code>protected</code> si on veut les
							restreindre.
						</p>
					</section>

					<section>
						<h3>Constructeurs auxiliaires</h3>
						<p>On peut définir d’autres constructeurs d’une classe :</p>
						<pre><code class="language-scala" data-line-numbers="4-6">class Account(private val clock: Clock):

  def this() =
    this(Clock.systemUTC())
    println("Account constructor with UTC clock")</code></pre>
						<p class="fragment">Souvent inutiles, car</p>
						<ol class="fragment">
							<li>
								Scala permet de définir des valeurs par défaut aux paramètres du constructeur principal
							</li>
							<li>L’objet companion d’une classe peut définir des <em>factory methods</em>.</li>
						</ol>
					</section>

					<section>
						<h2>Différents types d’outils</h2>
						<ul>
							<li>Traits</li>
							<li>Classes</li>
							<li class="fragment">Objets companions</li>
						</ul>
					</section>

					<section>
						<p>Un objet companion est</p>
						<ol>
							<li>un <code>object</code> qui doit porter le même nom que la classe</li>
							<li>doit-être défini dans le même fichier que la classe</li>
						</ol>
					</section>

					<section>
						<h3>À quoi sert-il ?</h3>
						<ul>
							<li>À regrouper des fonctions qui ne sont pas dépendantes d’une instance, mais du type</li>
							<li>À définir des valeurs statiques</li>
							<li>À créer des <em>factory methods</em> (sucre syntaxique)</li>
						</ul>
						<pre class="fragment"><code class="language-scala" data-line-numbers="1-2|4|6-7|9|11-13">class Account(private val clock: Clock):
  // ...

object Account:

  def sum(accounts: Seq[Account]): Int =
    accounts.map(_.balance).sum

  val dateFormatter = DateTimeFormatter.ofPattern("d.M.y")

  def apply(name: String): Account =
    println(s"Creating account for $name")
    new Account(Clock.systemUTC())</code></pre>
					</section>

					<section>
						<h2>Différents types d’outils</h2>
						<ul>
							<li>Traits</li>
							<li>Classes</li>
							<li>Objets companions</li>
							<li class="fragment">Case classes</li>
						</ul>
					</section>

					<section>
						<p>Les case classes servent à modéliser des structures de données immuables</p>
						<pre class="fragment"><code class="language-scala" data-line-numbers="1-5|7-8">case class Transaction(
  date: LocalDate,
  amount: Int,
  balance: Int
)

val deposit =
  Transaction(LocalDate.parse("2024-05-22"), 20000, 25398)</code></pre>
					</section>

					<section>
						<p>Elles ont des propriétés suplémentaires que les classes n’ont pas</p>
					</section>

					<section>
						<p>Méthode <code>unapply</code> générée permettant le pattern matching</p>
						<pre class="fragment"><code class="language-scala">transaction match:
  case Transaction(_, 0     , _)               => "zero"
  case Transaction(_, amount, _) if amount > 0 => "positive"
  case Transaction(_, amount, _)               => "negative"</code></pre>
					</section>

					<section>
						<p>Méthode <code>copy</code> permettant de créer des copies modifiées d’une instance</p>
						<pre class="fragment"><code class="language-scala">val toEuros: Transaction = transaction.copy(
  amount  = amount  * 656,
  balance = balance * 656
)</code></pre>
					</section>

					<section>
						<p>
							Méthodes <code>equals</code> et <code>hashCode</code> permettant de garantir l’unicité et la
							comparaison d’instances
						</p>
						<p>Méthode <code>toString</code> affichant les données compréhensibles d’une instance</p>
						<pre class="fragment"><code class="language-scala">println(deposit)</code></pre>
						<pre class="fragment"><code>Transaction(2024-05-22,20000,25398)</code></pre>
					</section>

					<section data-background="#336699" data-background-gradient="radial-gradient(#336699, #003366)">
						<h3>Exercice Pratique</h3>
						<p>Écrire une classe <code>Account</code><br>qui expose les méthodes ci-dessous :</p>
						<ul>
							<li><code>deposit(Int): Unit</code></li>
							<li><code>withdraw(Int): Unit</code></li>
							<li><code>printStatement(): String</code></li>
						</ul>
						<p>Voici un exemple de statement :</p>
						<pre>Date        Amount  Balance
24.12.2015   +500      500
23.8.2016    -100      400</pre>
					</section>

					<section data-background="#339966" data-background-gradient="radial-gradient(#339966, #003333)">
						<h3>Corrigé : classe Account</h3>
						<pre><code class="language-scala" data-line-numbers="1-15|17-24">import Account.Transaction

import java.time.ZoneOffset.UTC
import java.time.Clock
import scala.collection.mutable

class Account(private val clock: Clock):

  private val transactions = mutable.ListBuffer[Transaction]()
  private var balance = 0

  def deposit(amount: Int): Unit =
    balance += amount
    val now = clock.instant().atZone(UTC).toLocalDate
    transactions.append(Transaction(now, amount, balance))

  def withdraw(amount: Int): Unit =
    balance -= amount
    val now = clock.instant().atZone(UTC).toLocalDate
    transactions.append(Transaction(now, -amount, balance))

  def printStatement(): String = transactions
    .map(_.toString)
    .mkString("Date       Amount Balance\n", "\n", "")</code></pre>
					</section>

					<section data-background="#339966" data-background-gradient="radial-gradient(#339966, #003333)">
						<h3>Corrigé : objet companion de la classe Account</h3>
						<pre><code class="language-scala">import java.time.format.DateTimeFormatter
import java.time.LocalDate

object Account:

  private val dateFormatter =
    DateTimeFormatter.ofPattern("d.M.y")

  case class Transaction(date: LocalDate,
                         amount: Int,
                         balance: Int):
    override def toString: String =
      val formattedDate = date.format(dateFormatter)
      "%-10s %+5d %7d".format(formattedDate, amount, balance)</code></pre>
					</section>

					<section data-background="#336699" data-background-gradient="radial-gradient(#336699, #003366)">
						<h3>Contrôle continu</h3>
						<p>Écrire une version de <code>Account</code><br>en programmation fonctionnelle pure</p>
						<p>
							L’interface est libre : à vous de choisir ce qui correspond le mieux au design fonctionnel
						</p>
						<pre>Date        Amount  Balance
24.12.2015   +500      500
23.8.2016    -100      400</pre>
					</section>

					<section data-background="#339966" data-background-gradient="radial-gradient(#339966, #003333)">
						<h3>Corrigé : test unitaire</h3>
						<pre><code class="language-scala" data-line-numbers="5-11|12|13-15">import munit.FunSuite
import java.time.LocalDate
class AccountSuite extends FunSuite:
  test("should use account"):
    val account = Account.withdraw(
      Account.deposit(
        Account.empty,
        LocalDate.parse("2015-12-24"),
        500),
      LocalDate.parse("2016-08-23"),
      100)
    assertEquals(Account.printStatement(account),
      """Date       Amount Balance
        |24.12.2015  +500     500
        |23.8.2016   -100     400""".stripMargin)</code></pre>
					</section>

					<section data-background="#339966" data-background-gradient="radial-gradient(#339966, #003333)">
						<h3>Corrigé : fonctions sur Account</h3>
						<pre><code class="language-scala" data-line-numbers="3|5|7|7-15">import java.time.LocalDate

case class Account(private val transactions: Seq[Transaction])

case class Transaction(date: LocalDate, amount: Int)

object Account:
  def empty: Account = Account(Seq.empty)
  def deposit(account: Account, date: LocalDate,
              amount: Int): Account =
    Account(account.transactions :+ Transaction(date, amount))
  def withdraw(account: Account, date: LocalDate,
               amount: Int): Account =
    Account(account.transactions :+ Transaction(date, -amount))
  def printStatement(account: Account): String = ???</code></pre>
					</section>

					<section data-background="#339966" data-background-gradient="radial-gradient(#339966, #003333)">
						<h3>Corrigé : affichage du statement</h3>
						<pre><code class="language-scala" data-line-numbers="2-4|5-11|13-16">object Account:
  def printStatement(account: Account): String =
    "Date       Amount Balance" +
      printStatement(account.transactions, 0)
  private def printStatement(transactions: Seq[TransactionFP],
                             balance: Int): String =
    transactions match
      case Nil => ""
      case TransactionFP(date, amount) :: tail =>
        "\n" + printTransaction(date, amount, balance + amount)
             + printStatement(tail, balance + amount)
  private val dateFormatter = DateTimeFormatter.ofPattern("d.M.y")
  private def printTransaction(date: LocalDate, amount: Int,
                               balance: Int): String =
    "%-10s %+5d %7d".format(date.format(dateFormatter), amount,
                            balance)</code></pre>
					</section>

				</section>

				<section aria-description="3. Types et polymorphisme">
					<section><h1>Types et polymorphisme</h1></section>

					<section aria-description="3.1 Qu’est-ce qu’un type ?">
					    <h2>Qu’est-ce qu’un type ?</h2>
						<p>Identifie sans ambiguité des définitions de structures de données.</p>
						<p class="fragment">
							Fondation de Scala en tant que langage typé statiquement : le compilateur connait et vérifie à
							la compilation les interactions entre les structures de données, les arguments, les types de
							retour.
						</p>
					</section>

					<section aria-description="3.2 Inférence">
						<h3>Inférence</h3>
						<p>
							Bien que statiquement typé, Scala permet une relative souplesse dans la déclaration des
							symboles. Le compilateur <em>devine</em> les types des variables si le contexte est suffisant.
						</p>
						<pre class="fragment"><code class="language-scala" data-line-numbers="1-2|3-6">val x: Int = 1
val y: Double = 1
val a = 1                           // Int
val b = 1.0                         // Double
val l = List(1, 2, 3)               // List[Int]
val m = Map(1 -> "one", 2 -> "two") // Map[Int, String]</code></pre>
					</section>

					<section aria-description="3.3 Génériques">
						<h3>Génériques</h3>
						<p>Des classes ou des traits qui prennent des types en paramètre. <em>DRY</em><sup>tm</sup></p>
						<pre class="fragment"><code class="language-scala">class Stack[A]:
  private var elements: List[A] = Nil
  def push(x: A): Unit = elements = elements.prepended(x)
  def peek: A = elements.head
  def pop(): A =
    val head = peek
    elements = elements.tail
    head</code></pre>
						<pre class="fragment"><code class="language-scala">val stack = Stack[Int]
stack.push(1)
stack.push(2)
println(stack.pop()) // 2
println(stack.pop()) // 1</code></pre>
					</section>

					<section aria-description="3.4 Types intersection">
						<h3>Types intersection</h3>
						<p>Le type <code>A & B</code> représente les valeurs qui sont</p>
						<ul>
							<li><strong>à la fois</strong> de type <code>A</code></li>
							<li><strong>et</strong> de type <code></code>B</li>
						</ul>
						<pre class="fragment"><code class="language-scala" data-line-numbers="1-2|4-5|7-9">trait Resettable:
  def reset(): Unit

trait Growable[A]:
  def add(a: A): Unit

def f(x: Resettable & Growable[String]): Unit =
  x.reset()
  x.add("first")</code></pre>
					</section>

					<section aria-description="3.5 Types unions">
						<h3>Types unions</h3>
						<p>Le type <code>A | B</code> représente les valeurs qui sont</p>
						<ul>
							<li><strong>soit</strong> de type <code>A</code></li>
							<li><strong>ou</strong> de type <code></code>B</li>
						</ul>
						<pre class="fragment"><code class="language-scala" data-line-numbers="1-2|4-8">case class Username(name: String)
case class Password(hash: Hash)

def help(id: Username | Password) =
  val user = id match
    case Username(name) => lookupName(name)
    case Password(hash) => lookupPassword(hash)
  // ...</code></pre>
						<p class="fragment">
							Ici pas besoin de créer un trait scelé ou une enumeration <em>en avance</em>.
						</p>
					</section>

					<section aria-description="3.6 Typeclasses">
						<h3>Typeclasses</h3>
						<p>
							C’est un type abstrait et paramétré qui permet d’ajouter des comportements sur des types de
							données sans avoir besoin de les sous-typer.
						</p>
						<pre class="fragment"><code class="language-scala">trait Showable[A]:
  extension (a: A) def show: String</code></pre>
						<pre class="fragment"><code class="language-scala">case class Person(firstName: String, lastName: String)</code></pre>
						<pre class="fragment"><code class="language-scala" data-line-numbers="1-3|1-6">given Showable[Person] with
  extension (p: Person) def show: String =
    s"${p.firstName} ${p.lastName}"

val person = Person("John", "Doe")
println(person.show)</code></pre>
					</section>

					<section aria-description="3.6 Exemples dans cats">
						<h4>Exemples dans cats</h4>
						<ul>
							<li><code>Fonctor</code></li>
							<li><code>Applicative</code></li>
							<li><code>Semigroup</code></li>
							<li><code>Monoid</code></li>
						</ul>
					</section>

					<section aria-description="3.6 Exercice pratique" data-background="#336699" data-background-gradient="radial-gradient(#336699, #003366)">
						<h3>Exercice pratique</h3>
						<p>Implémenter un <em>monoid</em></p>
						<p>Un monoid est un type qui a une opération binaire associative et un élément neutre.</p>
						<pre class="fragment"><code class="language-scala">trait Monoid[A]:
  def combine(x: A, y: A): A
  def empty: A</code></pre>
						<pre class="fragment"><code class="language-scala" data-line-numbers="3-5|1,7">import Result.{Error, Success}

enum Result:
  case Success(count: Int)
  case Error(message: String)

case class Report(ok: List[Success], ko: List[Error]</code></pre>
					</section>

					<section aria-description="3.6 Exercice pratique Test unitaire" data-background="#336699" data-background-gradient="radial-gradient(#336699, #003366)">
						<h3>Exercice pratique : test unitaire</h3>
						<pre><code class="language-scala">import cats.kernel.Monoid
import monoid.Report.{fromResult, given}
import monoid.Result.{Error, Success}
import munit.FunSuite</code></pre>
						<pre><code class="language-scala">class ResultSuite extends FunSuite:

  test("should aggregate successes and errors"):
    val success1: Success = Success(10)
    val error: Error = Error("Null reference encountered")
    val success2: Success = Success(42)
    val results: Seq[Result] = Vector(success1, error, success2)
    val reports: Seq[Report] = results.map(fromResult)

    val combinedReport = Monoid.combineAll(reports)

    assertEquals(
      obtained = combinedReport,
      actual   = Report(List(success1, success2), List(error)))</code></pre>
					</section>

					<section aria-description="3.6 Exercice pratique Solution" data-background="#339966" data-background-gradient="radial-gradient(#339966, #003333)">
						<h3>Exercice pratique : solution</h3>
						<pre><code class="language-scala" data-line-numbers="1,8-12">object Report:
  def fromResult(result: Result): Report = result match
    case success: Success =>
                  Report(ok = List(success), ko = List.empty)
    case error: Error     =>
                  Report(ok = List.empty, ko = List(error))

  given Monoid[Report] with
    def combine(a: Report, b: Report): Report =
                  Report(ok = a.ok ++ b.ok, ko = a.ko ++ b.ko)
    def empty: Report =
                  Report(ok = List.empty, ko = List.empty)</code></pre>
					</section>
				</section>

				<section aria-description="4. Gestion des effets en programmation fonctionnelle">
					<h2>Gestion des effets en programmation fonctionnelle</h2>
					<!-- effets, puretés, monades (Future, Either, Try, Option, List) -->
				</section>

				<section aria-description="5. Manipulations et cas pratiques">
					<h2>Manipulations et cas pratiques</h2>
				</section>

			</div>

		</div>

		<script src="../lib/revealjs/dist/reveal.js"></script>
		<script src="../lib/revealjs/plugin/highlight/highlight.js"></script>
		<script>

			// Also available as an ES module, see:
			// https://revealjs.com/initialization/
			Reveal.initialize({
				controls: true,
				progress: true,
				center: true,
				hash: true,

				plugins: [ RevealHighlight ],

				pdfSeparateFragments: false
			});

		</script>

	</body>
</html>