<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Programmation fonctionnelle avec Scala</title>

		<meta name="description" content="Cours sur la programmation fonctionnelle avec Scala">
		<meta name="author" content="Sébastian Le Merdy">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0">

		<link rel="stylesheet" href="../lib/revealjs/dist/reset.css">
		<link rel="stylesheet" href="../lib/revealjs/dist/reveal.css">
		<link rel="stylesheet" href="../lib/revealjs/dist/theme/beige.css" id="theme">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="../lib/revealjs/plugin/highlight/monokai.css">
	</head>

	<body>

		<div class="reveal">

			<div class="slides">

<!--
          Nom matière : Programmation fonctionnelle avec Scala
     Objectif matière : Ce cours a pour objectif de présenter les concepts de la programmation fonctionnelle. Il est en
                        effet important pour un élève ingénieur d’être familier avec les différents paradigmes qui
                        fondent les nombreux langages de programmation qu’ils seront amenés à utiliser ou à comprendre
                        car étant aujourd’hui adoptés de plus en plus dans de nombreux langages populaires (Python, Java
                        8, Javascript, Rust…).
                        L’introduction des concepts inhérents au paradigme fonctionnel seront introduits en début de
                        cours et ce de façon indépendante d’un langage de programmation, de sorte que tout étudiant
                        puisse en comprendre les principes, la philosophie et puisse ensuite les appliquer dans le
                        langage de son choix. De plus Scala sera utilisé comme langage d’exemple pour le cours.
                        Au long de ce cours nous aborderons de nombreux aspects du langage Scala, notamment le système
                        de type, le polymorphisme, la complémentarité entre le paradigme objet et le paradigme
                        fonctionnel et nous appliquerons ces concepts sur un projet de programmation de type CLI, de
                        sorte que tout étudiant ayant suivi ce cours puisse être à même de monter en compétence sur un
                        projet professionnel.
Description détaillée : 1. Introduction à la programmation fonctionnelle
                           - concepts : fonction, pureté, composition, récursivité
					    2. Introduction à Scala
					       - concepts : présentation fonctionnelle de Scala, présentation objet de Scala
					    3. Types et polymorphisme
					       - concepts : formes de typage, generics, typeclass, sous-typage, types avancés
					    4. Gestion des effets en programmation fonctionnelle
					       - concepts : effets, puretés, monades (Future, Either, Try, Option, List)
					    5. Manipulations et cas pratiques
Modalité d’évaluation : - CC - ÉCRIT
                        - Partiel - Projet avec soutenance
 Exemple d’évaluation : Construction d’une application en Scala en suivant les préceptes de programmation fonctionnelle
                        et de modélisation abordés pendant le cours (pilotage d'une tondeuse à gazon automatique,
                        destinée aux surfaces rectangulaires).
-->


				<section aria-description="Programmation fonctionnelle avec Scala">
					<h1>Programmation fonctionnelle avec Scala</h1>
				</section>

				<section aria-description="Introduction">
					<section>
						<h2>Tour de table &#128064;</h2>
					</section>

					<section>
						<h3>Enseignant</h3>
						<h4>Sébastian Le Merdy</h4>
						<p><strong>19 ans</strong> d’expérience professionnelle<br>dans le développement</p>
					</section>

					<section>
						<p>ESN &#128558;</p>
						<dl>
							<dt>
							  <img src="img/logo-xebia.png" alt="Xebia" style="width: 5em">
							</dt>
							<dd>
								<img src="img/logo-societe-generale.png" alt="Société Générale" style="width: 2em">
								<img src="img/logo-colissimo.png" alt="Colissimo" style="width: 2em">
								<img src="img/logo-libon.png" alt="Libon" style="width: 2em">
								<img src="img/logo-vidal.png" alt="Vidal" style="width: 2em">
								<img src="img/logo-michelin.png" alt="Michelin" style="width: 2em">
								<img src="img/logo-bisam.png" alt="Bisam" style="width: 3em">
							</dd>
							<dt>
								<img src="img/logo-elosi.png" alt="Elosi" style="width: 3em">
							</dt>
							<dd>
								<img src="img/logo-rsi.png" alt="Rsi" style="width: 3em">
								<img src="img/logo-gmf.png" alt="GMF" style="width: 1em">
							</dd>
						</dl>
					</section>

					<section>
						<p>Plus récemment dans un organisme de paiement</p>
						<p>
							<img src="img/logo-nickel.png" alt="Nickel" style="width: 6em">
						</p>
					</section>

					<section>
						<p>Actuellement chez un <strong>éditeur</strong> SaaS<br><em>dans la data</em></p>
						<p>
							<img src="img/logo-zeenea.png" alt="Zeenea" style="width: 10em">
						</p>
					</section>

					<section>
						<p>Principalement autour des langages JVM</p>
						<p>
							<img src="img/logo-java.png" alt="Java">
							<img src="img/logo-scala.png" alt="Scala">
						</p>
					</section>

					<section>
						<h3>Et vous ?</h3>
						<p>Quelle expérience avec des langages fonctionnels ?</p>
						<ul>
							<li>OCaml</li>
							<li>Haskell</li>
							<li>F#</li>
							<li>C</li>
						</ul>
					</section>

					<section>
						<p>Connaissez-vous les mots-clés ?</p>
						<ul>
							<li>fonctions pures</li>
							<li>récursivité</li>
							<li>effets de bord</li>
							<li>monades</li>
						</ul>
					</section>

					<section>
						<p>Mais rentrons dans le vif du sujet</p>
						<p>FP&#8230;</p>
					</section>
				</section>

				<section aria-description="1. Introduction à la programmation fonctionnelle">
					<h2>Introduction à la programmation fonctionnelle</h2>
				</section>

				<section aria-description="1.1 Fonction">
					<section>
					    <h3>Fonction</h3>
					</section>

					<section>
						<h4>Définition mathématique</h4>
						<p class="section">
							<code>E &#8594; F</code><br>
							<code>x &#8614; f(x)</code>
						</p>
					</section>

					<section>
						<p>
							Il s’agit d’une <strong>transformation</strong><br>
							d’une valeur appartement à l’ensemble de départ<br>
							vers une valeur appartenant à l’ensemble d’arrivée.
						</p>
					</section>

					<section data-transition="none">
						<h4>Exemple : des tâches et leur statut</h4>
						<img src="img/tasks-01.png" alt="des statuts de tâche">
					</section>

					<section data-transition="none">
						<h4>Des transitions entre tâches</h4>
						<img src="img/tasks-02.png" alt="des statuts de tâche et des transitions">
					</section>

					<section data-transition="none">
						<h4>Ensembles de départ et d'arrivée</h4>
						<img src="img/tasks-03.png" alt="ensemble de départ et ensemble d’arrivée de findTransitions()">
					</section>

					<section>
						<pre><code class="language-scala">enum TaskStatus:
  case Created, Started, InReview, Done</code></pre>
						<pre class="fragment"><code class="language-scala">enum TaskTransition:
  case Start, Finish, RequestChange, Accept</code></pre>
						<pre class="fragment"><code class="language-scala">def findTransitions: TaskStatus => Seq[TaskTransition] =
  case Created  => Seq(Start)
  case Started  => Seq(Finish)
  case InReview => Seq(RequestChange, Accept)
  case Done     => Seq()</code></pre>
					</section>

					<section>
						<h4>Règle tirée de la réalité</h4>
						<p>Toujours chercher à diminuer la taille des ensembles de départ et d'arrivée permet de</p>
						<ol>
							<li>Simplifier le code et la lisibilité</li>
							<li>Éviter les bugs</li>
							<li>Éviter les attaques</li>
							<li>Ne pas implémenter des cas qui ne serviront jamais</li>
						</ol>
					</section>

					<section data-background="#336699" data-background-gradient="radial-gradient(#336699, #003366)">
						<h4>Travail pratique</h4>
						<p>Mettre en place un environnement de développement pour écrire sa première fonction en Scala</p>
						<ol>
							<li>Télécharger <a href="https://www.jetbrains.com/fr-fr/idea/download">IntelliJ IDEA Community Edition</a></li>
							<li>Installer IntelliJ IDEA Community Edition</li>
							<li>Installer le plugin Scala</li>
							<li>Générer un nouveau projet</li>
						</ol>
					</section>

					<section data-background="#336699" data-background-gradient="radial-gradient(#336699, #003366)">
						<h4>Travail pratique</h4>
						<img src="img/new-project.png" alt="Nouveau projet avec IntelliJ IDEA Community Edition" style="max-width: 75%">
					</section>

					<section data-background="#336699" data-background-gradient="radial-gradient(#336699, #003366)">
						<h4>Travail pratique</h4>
						<img src="img/new-project-firstFunction.png" alt="Résultat de l’exécution de notre première fonction" style="max-width: 70%">
					</section>

					<section>
						<h4>Caractéristiques d’une fonction</h4>
						<ul>
							<li>totale</li>
							<li>déterministe</li>
							<li>sans effet de bord</li>
						</ul>
					</section>
				</section>

				<section aria-description="1.2 Pureté">
					<section>
						<h3>Pureté</h3>
					</section>

					<section>
                        <pre><code class="language-scala">def sayHello(niceMessage: String): Unit =
  println(s"Hello $niceMessage")</code></pre>

                        <pre class="fragment"><code class="language-scala">sayHello("world!")</code></pre>

						<pre class="fragment"><code class="language-plaintext">Hello world!</code></pre>
					</section>

					<section>
                        <pre><code class="language-scala">def dice(): Int =
  Random.nextInt(6) + 1</code></pre>

                        <pre class="fragment"><code class="language-scala">dice()
val res0: Int = 5</code></pre>

						<pre class="fragment"><code class="language-scala">dice()
val res1: Int = 3</code></pre>
					</section>

					<section>
                        <pre><code class="language-scala">def nowPlus(days: Long): Instant =
  Instant.now().plus(days, ChronoUnit.DAYS)</code></pre>

                        <pre class="fragment"><code class="language-scala">nowPlus(3)
val res0: java.time.Instant = 2024-03-05T18:55:34.125784Z</code></pre>

						<pre class="fragment"><code class="language-scala">nowPlus(5)
val res1: java.time.Instant = 2024-03-07T18:55:34.215660Z</code></pre>
					</section>

					<section>
                        <pre><code class="language-scala">def saveArticle(id: UUID, content: String, author: Author)(
    database: Database
): Boolean =
  database.executeQuery(
    """INSERT INTO Article(id, content, author_name, author_email)
      |VALUES (:id, :content, :author_name, :author_email);
      |""".stripMargin,
    "id" -> id,
    "content" -> content,
    "author_name" -> author.name,
    "author_email" -> author.email
  )</code></pre>

						<pre class="fragment"><code class="language-scala">saveArticle(
    UUID.fromString("0d975fff-44dc-4110-b21a-1f31148969b8"),
    "&lt;p&gt;Great content&lt;/p&gt;",
    Author("Sébastian", "seb@example.com")
  )(postgresql)
val res0: Boolean = true</code></pre>
					</section>

					<section>
						<p>Toutes ces fonctions sont <em>impures</em> car :</p>
						<ul>
							<li>Deux appels successifs ne produisent pas la même valeur en retour ;</li>
							<li>Elles créent des effets de bord.</li>
						</ul>
					</section>

					<section>
						<h4>Pourquoi les fonctions pures sont-elles intéressantes ?</h4>
						<ul>
							<li class="fragment">transparence référentielle</li>
							<li class="fragment">immuabilité
								<ul>
									<li>des paramètres en entrée</li>
									<li>une valeur produite en retour</li>
								</ul>
						</ul>
						<p class="fragment">Permet donc des <strong>optimisations massivement parallélisables</strong></p>
					</section>

					<section data-background="#336699" data-background-gradient="radial-gradient(#336699, #003366)">
						<h4>Travail pratique</h4>
						<p>Écrire une fonction pure qui débarrasse les emails suivant du bruit:</p>
						<pre>"kai@example.com
sacha@example.net"
"cruz@example.org"
  noam@example.com    </pre>
					</section>

					<section data-background="#336699" data-background-gradient="radial-gradient(#336699, #003366)">
						<div>
							Utiliser un framework de test unitaire<br>
							<pre><code class="language-scala">libraryDependencies +=
    "org.scalameta" %% "munit" % "0.7.29" % Test</code></pre>
							<pre><code class="language-scala">import munit.FunSuite

class EmailCleaner extends FunSuite:

  private def clean(notCleanedEmail: String): String = ???

  test("emailCleaner"):
    assertEquals(
      obtained = clean(""""kai@example.com"""),
      expected = "kai@example.com"
    )</code></pre>
						</div>
					</section>

					<section data-background="#339966" data-background-gradient="radial-gradient(#339966, #003333)">
						<h3>Les tests unitaires</h3>
						<pre><code class="language-scala">import EmailCleaner.clean
import munit.FunSuite

class EmailCleanerSuite extends FunSuite:
  test("remove starting quote"):
    assertEquals(clean(""""kai@example.com"""),
                         "kai@example.com")
  test("remove trailing quote"):
    assertEquals(clean("""sacha@example.net""""),
                         "sacha@example.net")
  test("remove starting and trailing quote"):
    assertEquals(clean(""""cruz@example.org""""),
                         "cruz@example.org")
  test("remove starting and trailing spaces"):
    assertEquals(clean("""  noam@example.com    """),
                         "noam@example.com")</code></pre>
					</section>

					<section data-background="#339966" data-background-gradient="radial-gradient(#339966, #003333)">
						<h3>L’implémentation</h3>
						<pre><code class="language-scala">object EmailCleaner:

  private val        startWithQuote = """^"(.+)""".r
  private val         endsWithQuote = """(.+)"$""".r
  private val  startAndEndWithQuote = """^"(.+)"$""".r
  private val startAndEndWithSpaces = """^\s+(.*?)\s+$""".r

  def clean(notCleanedEmail: String): String =
    notCleanedEmail match
      case startAndEndWithQuote(email) => email
      case startWithQuote(email) => email
      case endsWithQuote(email) => email
      case startAndEndWithSpaces(email) => email
      case _ => notCleanedEmail</code></pre>
					</section>

					<section>
						<p>Les fonctions pures sont importantes : ce sont les blocs de base de la programmation fonctionnelle.</p>
						<p class="fragment">Mais comment aller plus loin et finir par écrire de vrais programmes ?</p>
					</section>
				</section>

				<section aria-description="1.3 Composition">
					<section>
						<h3>Composition</h3>
					</section>

					<section>
						<h4>Définition mathématique</h4>
						<p><code>f &#8728; g</code></p>
						<p><code>f(g(x))</code></p>
					</section>

					<section>
						<h4>D’un point de vue génie logiciel</h4>
						<p>Il s’agit d’un moyen de garantir</p>
						<ol>
							<li>la ré-utilisabilité du code</li>
							<li>le bon niveau d’abstraction</li>
							<li>la lisibilité</li>
						</ol>
					</section>

					<section>
						<pre><code class="language-scala">case class User(name: String, age: Int)</code></pre>

						<pre class="fragment"><code class="language-scala">enum Category:
  case Young, Adult, Old</code></pre>

						<pre class="fragment"><code class="language-scala">val categoryByMaxAges: Map[Int, Category] =
  Map(
    24 -> Category.Young,
    64 -> Category.Adult,
    Integer.MAX_VALUE -> Category.Old
  )</code></pre>

						<pre class="fragment"><code class="language-scala">val discountByCategories: Map[Category, Int] =
  Map(
    Category.Young -> 25,
    Category.Adult -> 0,
    Category.Old -> 35
  )</code></pre>
					</section>

					<section>
						<pre><code class="language-scala">def computePrice(
    user: User,
    categories: Map[Int, Category],
    price: Long,
    discounts: Map[Category, Int]
): Long = price - price * discounts(
  categories
    .filter { case (maxAge, category) => maxAge >= user.age }
    .minBy { case (maxAge, category) => maxAge }
    ._2
) / 100</code></pre>

						<pre class="fragment"><code class="language-scala">computePrice(          computePrice(          computePrice(
  User("Emma", 16),      User("Nicolas", 41),   User("Martine", 67),
  categoryByMaxAges,     categoryByMaxAges,     categoryByMaxAges,
  price = 1999,          price = 5500,          price = 4999,
  discountByCategories   discountByCategories   discountByCategories
)                      )                      )
val res0: Long = 1500  val res1: Long = 5500  val res2: Long = 3250</code></pre>
					</section>

					<section>
						<h3>Décomposons</h3>
					</section>

					<section>
						<pre><code class="language-scala">
def computePrice(
    user: User,
    categories: Map[Int, Category],
    price: Long,
    discounts: Map[Category, Int]
): Long =
  computePrice(
    price,
    computeDiscount(user, categories, discounts)
  )
						</code></pre>
					</section>

					<section>
						<pre><code class="language-scala">
def computePrice(price: Long, discount: Long): Long =
  price - price * discount / 100
						</code></pre>
					</section>

					<section>
						<pre><code class="language-scala">
def computeDiscount(
    user: User,
    categories: Map[Int, Category],
    discounts: Map[Category, Int]
): Long = discounts(findCategory(user, categories))
						</code></pre>
					</section>

					<section>
						<pre><code class="language-scala">
def findCategory(
    user: User,
    categories: Map[Int, Category]
): Category =
  val (_, category) = categories
    .filter { case (maxAge, category) => maxAge >= user.age }
    .minBy { case (maxAge, category) => maxAge }
  category
						</code></pre>
					</section>

					<section data-background="#336699" data-background-gradient="radial-gradient(#336699, #003366)">
						<h4>Travail pratique</h4>
						<ol>
							<li>Écrire deux fonctions pures :
								<ol>
									<li><code>times2</code> qui multiplie un <code>Int</code> par 2</li>
									<li><code>addOne</code> qui ajoute 1 au <code>Int</code> passé en paramètre</li>
								</ol>
							</li>
							<li class="fragment">Composer ces deux fonctions pour obtenir une fonction qui multiplie un <code>Int</code> par 2 puis ajoute 1.</li>
						</ol>
					</section>

					<section data-background="#339966" data-background-gradient="radial-gradient(#339966, #003333)">
						<h4>Corrigé</h4>
						<pre><code>object Composition:

  def times2(value: Int): Int = value * 2

  def addOne(value: Int): Int = value + 1

  def times2PlusOne(value: Int): Int = addOne(times2(value))

  @main def compositionMain(): Unit =
    println(times2PlusOne(5)) // 11</code></pre>
					</section>

					<section>
						<h4>Les fonctions : ces citoyens de premier ordre</h4>
					</section>

					<section>
						<p>Une fonction est considérée comme un type de données comme les autres.</p>
						<ul>
							<li class="fragment">peut-être passée en argument d’une autre fonction</li>
						</ul>
					</section>

					<section>
						<pre><code class="language-scala">def logBeforeAndAfter(message: String, task: () => Unit): Unit =
  println(s"before $message")
  task()
  println(s" after $message")</code></pre>

						<pre class="fragment"><code class="language-scala">logBeforeAndAfter("hello", () => { println("Hello World!") })</code></pre>

						<pre class="fragment"><code class="language-plaintext">before hello
Hello World!
 after hello</code></pre>
					</section>

					<section>
						<pre><code class="language-scala">def logBeforeAndAfterResult(
    message: String,
    computeResult: String => Long
): Unit =
  println(s"before $message")
  println(s"result ${computeResult(message)}")
  println(s" after $message")</code></pre>

						<pre class="fragment"><code class="language-scala">logBeforeAndAfterResult("hello", message => message.length)</code></pre>
						<pre class="fragment"><code class="language-plaintext">before hello
result 5
 after hello</code></pre>
					</section>

					<section>
						<p>Une fonction est considérée comme un type de données comme les autres.</p>
						<ul>
							<li>peut-être passée en argument d’une autre fonction</li>
							<li class="fragment">peut-être retournée par une autre fonction</li>
						</ul>
					</section>

					<section>
						<pre><code class="language-scala">def operationToCompute(operation: String): (Long, Long) => Long =
  operation match
    case "add"      => (left, right) => left + right
    case "subtract" => (left, right) => left - right
    case "multiply" => (left, right) => left * right
    case _          => (left, right) => Long.MinValue</code></pre>

						<pre class="fragment"><code class="language-scala">operationToCompute("add"     )(3, 2)
val res0: Long = 5</code></pre>

						<pre class="fragment"><code class="language-scala">operationToCompute("subtract")(3, 2)
val res1: Long = 1</code></pre>

						<pre class="fragment"><code class="language-scala">operationToCompute("multiply")(3, 2)
val res2: Long = 6</code></pre>

						<pre class="fragment"><code class="language-scala">operationToCompute("divide"  )(3, 2)
val res3: Long = -9223372036854775808</code></pre>
					</section>

					<section data-background="#336699" data-background-gradient="radial-gradient(#336699, #003366)">
						<h4>Travail pratique</h4>
						<p>Utiliser <code>compose</code> et/ou <code>andThen</code> pour composer <code>times2</code> et <code>addOne</code></p>
					</section>

					<section data-background="#339966" data-background-gradient="radial-gradient(#339966, #003333)">
						<h4>Corrigé</h4>
						<pre><code class="language-scala">object Composition:

  def times2(value: Int): Int = value * 2

  def addOne(value: Int): Int = value + 1

  def times2PlusOne(value: Int): Int = addOne(times2(value))
  def withCompose(value: Int): Int   = addOne.compose(times2)(value)
  def withAndThen(value: Int): Int   = times2.andThen(addOne)(value)

  @main def compositionMain(): Unit =
    println(times2PlusOne(5)) // 11
    println(withCompose(5))   // 11
    println(withAndThen(5))   // 11</code></pre>
					</section>
				</section>

				<section aria-description="1.4 Récursivité">
					<section>
						<h3>Récursivité</h3>
					</section>

					<section>
						<p>La possibilité pour une fonction de se rappeler elle-même. Permet de traiter :</p>
						<ul>
							<li>une structure de données elle-même récursive</li>
							<li>une collection</li>
						</ul>
					</section>

					<section>
						<h4>Implémentation</h4>
						<ol>
							<li>trouver une ou plusieurs conditions d’arrêt</li>
							<li>se rappeler soi-même avec des données transformées</li>
						</ol>
					</section>

					<section>
						<h4>Récursion terminale</h4>
						<p>L’appel récursif est la dernière évaluation dans l’implémentation de la fonction</p>
						<p>Permet d’éviter des épuisements de la pile d’exécution (aka StackOverflow®)</p>
					</section>

					<section>
						<h4>Exemple : lire un flux</h4>
						<pre><code class="language-scala">val input = """34
              |84
              |12
              |
              |32
              |28
              |9
              |7""".stripMargin</code></pre>
						<pre class="fragment"><code class="language-scala">@tailrec
def sums(
    input: List[String],
    acc: Seq[Long] = Vector.empty,
    sum: Long = 0
): Seq[Long] =
  input match
    case Nil        => acc :+ sum
    case "" :: tail => sums(tail, acc :+ sum)
    case n :: tail  => sums(tail, acc, sum + n.toLong)</code></pre>
						<pre class="fragment"><code class="language-scala">sums(input.linesIterator.toList)
val res0: Seq[Long] = Vector(130, 76)</code></pre>
					</section>

					<section data-background="#336699" data-background-gradient="radial-gradient(#336699, #003366)">
						<h4>Travail pratique</h4>
						<p>
							Calculer la somme<br>
							du premier et du dernier chiffre<br>
							de chacune des lignes<br>
							en n’utilisant que des fonctions récursives</p>
						<pre>two1nine
eightwothree
abcone2threexyz
xtwone3four
4nineeightseven2
zoneight234
7pqrstsixteen
</pre>
					</section>

					<section data-transition="none" data-background="#336699" data-background-gradient="radial-gradient(#336699, #003366)">
						<h4>Travail pratique</h4>
						<p>
							Calculer la somme<br>
							du premier et du dernier chiffre<br>
							de chacune des lignes<br>
							en n’utilisant que des fonctions récursives</p>
						<pre>two1nine         -> 219         ->  29
eightwothree     -> 8wo3        ->  83
abcone2threexyz  -> abc123xyz   ->  13
xtwone3four      -> x2ne34      ->  24
4nineeightseven2 -> 49872       ->  42
zoneight234      -> z1ight234   ->  14
7pqrstsixteen    -> 7pqrst6teen ->  76
                                   281</pre>
					</section>

					<section data-background="#339966" data-background-gradient="radial-gradient(#339966, #003333)">
						<h4>Corrigé de la première fonction: test unitaire</h4>
						<pre><code class="language-scala">import SumAll.toNumber
import munit.FunSuite

class SumAllSuite extends FunSuite:

  test("toNumber"):
    assertEquals(toNumber("two1nine"),         "219")
    assertEquals(toNumber("eightwothree"),     "8wo3")
    assertEquals(toNumber("abcone2threexyz"),  "abc123xyz")
    assertEquals(toNumber("xtwone3four"),      "x2ne34")
    assertEquals(toNumber("4nineeightseven2"), "49872")
    assertEquals(toNumber("zoneight234"),      "z1ight234")
    assertEquals(toNumber("7pqrstsixteen"),    "7pqrst6teen")</code></pre>
					</section>

					<section data-background="#339966" data-background-gradient="radial-gradient(#339966, #003333)">
						<h4>Corrigé de la première fonction: implémentation</h4>
						<pre><code class="language-scala">object SumAll:

  def toNumber(value: String): String = value match
    case ""                         => "" // terminating scenario
    case s if s.startsWith("one")   => "1" + toNumber(s.drop(3))
    case s if s.startsWith("two")   => "2" + toNumber(s.drop(3))
    case s if s.startsWith("three") => "3" + toNumber(s.drop(5))
    case s if s.startsWith("four")  => "4" + toNumber(s.drop(4))
    case s if s.startsWith("five")  => "5" + toNumber(s.drop(4))
    case s if s.startsWith("six")   => "6" + toNumber(s.drop(3))
    case s if s.startsWith("seven") => "7" + toNumber(s.drop(5))
    case s if s.startsWith("eight") => "8" + toNumber(s.drop(5))
    case s if s.startsWith("nine")  => "9" + toNumber(s.drop(4))
    case s                          => s.take(1) + toNumber(s.drop(1))</code></pre>
					</section>

					<section data-background="#339966" data-background-gradient="radial-gradient(#339966, #003333)">
						<h4>Corrigé de la seconde fonction: test unitaire</h4>
						<pre><code class="language-scala">import SumAll.{firstAndLast, toNumber}
import munit.FunSuite

class SumAllSuite extends FunSuite:

  test("firstAndLastNumber"):
    assertEquals(firstAndLastNumber("219"),         "29")
    assertEquals(firstAndLastNumber("8wo3"),        "83")
    assertEquals(firstAndLastNumber("abc123xyz"),   "13")
    assertEquals(firstAndLastNumber("x2ne34"),      "24")
    assertEquals(firstAndLastNumber("49872"),       "42")
    assertEquals(firstAndLastNumber("z1ight234"),   "14")
    assertEquals(firstAndLastNumber("7pqrst6teen"), "76")

  test("toNumber"):
    () // …</code></pre></section>

					<section data-background="#339966" data-background-gradient="radial-gradient(#339966, #003333)">
						<h4>Corrigé de la seconde fonction: implémentation</h4>
						<pre><code class="language-scala">import scala.util.Try

object SumAll:

  def first(value: String): String = value match
    case ""                                  => ""
    case s if Try(s.take(1).toInt).isSuccess => s.take(1)
    case s                                   => first(s.drop(1))

  def last(value: String): String = first(value.reverse)

  def firstAndLastNumber(value: String): String =
    first(value) + last(value)

  def toNumber(value: String): String = ??? // …</code></pre>
					</section>

					<section data-background="#339966" data-background-gradient="radial-gradient(#339966, #003333)">
						<h4>Corrigé de la fonction principale: test unitaire</h4>
						<pre><code class="language-scala">import SumAll.{firstAndLastNumber, sumAll, toNumber}
import munit.FunSuite

class SumAllSuite extends FunSuite:

  test("sumAll"):
    assertEquals(sumAll("""two1nine
                          |eightwothree
                          |abcone2threexyz
                          |xtwone3four
                          |4nineeightseven2
                          |zoneight234
                          |7pqrstsixteen""".stripMargin), 281)

  test("firstAndLastNumber"):
	() // …

  test("toNumber"):
    () // …</code></pre>
					</section>

					<section data-background="#339966" data-background-gradient="radial-gradient(#339966, #003333)">
						<h4>Corrigé de la seconde fonction: implémentation</h4>
						<pre><code class="language-scala">import scala.jdk.StreamConverters.*
import scala.util.Try

object SumAll:

  def firstAndLastNumber(value: String): String = ??? // …

  def toNumber(value: String): String = ??? // …

  def sumAll(values: String): Int =
    values.lines().toScala(Vector)
      .map(toNumber)
      .map(firstAndLastNumber)
      .map(_.toInt)
      .sum</code></pre>
					</section>
				</section>

				<section aria-description="2. Introduction à Scala">
					<h2>Introduction à Scala</h2>
				</section>

				<section aria-description="2.1 Présentation fonctionnelle de Scala">
					<section>
						<h2>Présentation fonctionnelle de Scala</h2>
					</section>

					<section>
						<h3>Modéliser la donnée</h3>
						<p>ADT - Algebraic Data Types</p>
						<ul>
							<li class="fragment">
								Sum types : énumérations
								<pre><code class="language-scala">enum TaskStatus:
  case Created, Started,
    InReview, Done</code></pre>
							</li>
							<li class="fragment">
								Product types : case classes
								<pre><code class="language-scala">case class Task(
    name: String,
    status: TaskStatus
)</code></pre>
							</li>
						</ul>
					</section>

					<section>
						<h3>Décrire et appliquer des traitements</h3>
						<p>Écrire des fonctions</p>
						<pre class="fragment"><code class="language-scala">def findTransitions: TaskStatus => Seq[TaskTransition] =
  case Created  => Seq(Start)
  case Started  => Seq(Finish)
  case InReview => Seq(RequestChange, Accept)
  case Done     => Seq()</code></pre>
						<pre class="fragment"><code class="language-scala">def findTransitions(status: TaskStatus): Seq[TaskTransition] =
  status match
    case Created  => Seq(Start)
    case Started  => Seq(Finish)
    case InReview => Seq(RequestChange, Accept)
    case Done     => Seq()</code></pre>
					</section>

					<section>
						<h3>Notes sur les fonctions</h3>
						<p>
							Avec les ADT, on force les fonctions à être pures, car ces structures de données sont
							immuables.
						</p>
					</section>

					<section>
						<h3>Comment organiser le code ?</h3>
						<ul>
							<li>des méthodes dans les objets compagnions</li>
							<li>style modulaire avec des interfaces et des implémentations</li>
							<li>des méthodes dans les types de données immuables</li>
							<li>des méthodes d’extension pour ajouter les fonctionnalités aux types de données</li>
						</ul>
					</section>

					<section data-background="#336699" data-background-gradient="radial-gradient(#336699, #003366)">
						<h3>Exercice Pratique</h3>
						<p>Matrice de lumières : calcul de la consommation énergétique</p>
						<dl>
							<dt><code>turn on 0,0 through 999,999</code></dt>
							<dd>allume (ou laisse allumées) toutes les lumières</dd>
							<dt><code>toggle 0,0 through 999,0</code></dt>
							<dd>
								bascule la première ligne de 1000 lumières, éteignant celles qui étaient allumées et
								allumant celles qui étaient éteintes.
							</dd>
							<dt><code>turn off 499,499 through 500,500</code></dt>
							<dd>éteint (ou laisse éteintes) les quatres lumières du milieu.</dd>
						</dl>
					</section>

					<section data-background="#336699" data-background-gradient="radial-gradient(#336699, #003366)">
						<h3>Exercice Pratique : instructions</h3>
						<pre><code>turn on 887,9 through 959,629
turn on 454,398 through 844,448
turn off 539,243 through 559,965
turn off 370,819 through 676,868
turn off 145,40 through 370,997
turn off 301,3 through 808,453
turn on 351,678 through 951,908
toggle 720,196 through 897,994
toggle 831,394 through 904,860</code></pre>
						<p>Combien de lumières sont-elles allumées ?</p>
					</section>
				</section>

				<section aria-description="2.2 Présentation objet de Scala">
					<h2>Présentation objet de Scala</h2>
				</section>

				<section aria-description="3. Types et polymorphisme">
					<h2>Types et polymorphisme</h2>
				</section>

				<section aria-description="4. Gestion des effets en programmation fonctionnelle">
					<h2>Gestion des effets en programmation fonctionnelle</h2>
				</section>

				<section aria-description="5. Manipulations et cas pratiques">
					<h2>Manipulations et cas pratiques</h2>
				</section>

			</div>

		</div>

		<script src="../lib/revealjs/dist/reveal.js"></script>
		<script src="../lib/revealjs/plugin/highlight/highlight.js"></script>
		<script>

			// Also available as an ES module, see:
			// https://revealjs.com/initialization/
			Reveal.initialize({
				controls: true,
				progress: true,
				center: true,
				hash: true,

				plugins: [ RevealHighlight ]
			});

		</script>

	</body>
</html>