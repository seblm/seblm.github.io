<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Programmation fonctionnelle avec Scala</title>

		<meta name="description" content="Cours sur la programmation fonctionnelle avec Scala">
		<meta name="author" content="Sébastian Le Merdy">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0">

		<link rel="stylesheet" href="../lib/revealjs/dist/reset.css">
		<link rel="stylesheet" href="../lib/revealjs/dist/reveal.css">
		<link rel="stylesheet" href="../lib/revealjs/dist/theme/beige.css" id="theme">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="../lib/revealjs/plugin/highlight/monokai.css">
	</head>

	<body>

		<div class="reveal">

			<div class="slides">

<!--
          Nom matière : Programmation fonctionnelle avec Scala
     Objectif matière : Ce cours a pour objectif de présenter les concepts de la programmation fonctionnelle. Il est en
                        effet important pour un élève ingénieur d’être familier avec les différents paradigmes qui
                        fondent les nombreux langages de programmation qu’ils seront amenés à utiliser ou à comprendre
                        car étant aujourd’hui adoptés de plus en plus dans de nombreux langages populaires (Python, Java
                        8, Javascript, Rust…).
                        L’introduction des concepts inhérents au paradigme fonctionnel seront introduits en début de
                        cours et ce de façon indépendante d’un langage de programmation, de sorte que tout étudiant
                        puisse en comprendre les principes, la philosophie et puisse ensuite les appliquer dans le
                        langage de son choix. De plus Scala sera utilisé comme langage d’exemple pour le cours.
                        Au long de ce cours nous aborderons de nombreux aspects du langage Scala, notamment le système
                        de type, le polymorphisme, la complémentarité entre le paradigme objet et le paradigme
                        fonctionnel et nous appliquerons ces concepts sur un projet de programmation de type CLI, de
                        sorte que tout étudiant ayant suivi ce cours puisse être à même de monter en compétence sur un
                        projet professionnel.
Description détaillée : 1. Introduction à la programmation fonctionnelle
                           - concepts : fonction, pureté, composition, récursivité
					    2. Introduction à Scala
					       - concepts : présentation fonctionnelle de Scala, présentation objet de Scala
					    3. Types et polymorphisme
					       - concepts : formes de typage, generics, typeclass, sous-typage, types avancés
					    4. Gestion des effets en programmation fonctionnelle
					       - concepts : effets, puretés, monades (Future, Either, Try, Option, List)
					    5. Manipulations et cas pratiques
Modalité d’évaluation : - CC - ÉCRIT
                        - Partiel - Projet avec soutenance
 Exemple d’évaluation : Construction d’une application en Scala en suivant les préceptes de programmation fonctionnelle
                        et de modélisation abordés pendant le cours (pilotage d'une tondeuse à gazon automatique,
                        destinée aux surfaces rectangulaires).
-->


				<section aria-description="Programmation fonctionnelle avec Scala">
					<h1>Programmation fonctionnelle avec Scala</h1>
				</section>

				<section aria-description="Introduction">
					<section>
						<h2>Tour de table &#128064;</h2>
					</section>

					<section>
						<h3>Enseignant</h3>
						<h4>Sébastian Le Merdy</h4>
						<p><strong>19 ans</strong> d’expérience professionnelle<br>dans le développement</p>
					</section>

					<section>
						<p>ESN &#128558;</p>
						<dl>
							<dt>
							  <img src="img/logo-xebia.png" alt="Xebia" style="width: 5em">
							</dt>
							<dd>
								<img src="img/logo-societe-generale.png" alt="Société Générale" style="width: 2em">
								<img src="img/logo-colissimo.png" alt="Colissimo" style="width: 2em">
								<img src="img/logo-libon.png" alt="Libon" style="width: 2em">
								<img src="img/logo-vidal.png" alt="Vidal" style="width: 2em">
								<img src="img/logo-michelin.png" alt="Michelin" style="width: 2em">
								<img src="img/logo-bisam.png" alt="Bisam" style="width: 3em">
							</dd>
							<dt>
								<img src="img/logo-elosi.png" alt="Elosi" style="width: 3em">
							</dt>
							<dd>
								<img src="img/logo-rsi.png" alt="Rsi" style="width: 3em">
								<img src="img/logo-gmf.png" alt="GMF" style="width: 1em">
							</dd>
						</dl>
					</section>

					<section>
						<p>Plus récemment dans un organisme de paiement</p>
						<p>
							<img src="img/logo-nickel.png" alt="Nickel" style="width: 6em">
						</p>
					</section>

					<section>
						<p>Actuellement chez un <strong>éditeur</strong> SaaS<br><em>dans la data</em></p>
						<p>
							<img src="img/logo-zeenea.png" alt="Zeenea" style="width: 10em">
						</p>
					</section>

					<section>
						<p>Principalement autour des langages JVM</p>
						<p>
							<img src="img/logo-java.png" alt="Java">
							<img src="img/logo-scala.png" alt="Scala">
						</p>
					</section>

					<section>
						<h3>Et vous ?</h3>
						<p>Quelle expérience avec des langages fonctionnels ?</p>
						<ul>
							<li>OCaml</li>
							<li>Haskell</li>
							<li>F#</li>
							<li>C</li>
						</ul>
					</section>

					<section>
						<p>Connaissez-vous les mots-clés ?</p>
						<ul>
							<li>fonctions pures</li>
							<li>récursivité</li>
							<li>effets de bord</li>
							<li>monades</li>
						</ul>
					</section>

					<section>
						<p>Mais rentrons dans le vif du sujet</p>
						<p>FP&#8230;</p>
					</section>
				</section>

				<section aria-description="1. Introduction à la programmation fonctionnelle">
					<h2>Introduction à la programmation fonctionnelle</h2>
				</section>

				<section aria-description="1.1 Fonction">
					<section>
					    <h3>Fonction</h3>
					</section>

					<section>
						<h4>Définition mathématique</h4>
						<p class="section">
							<code>E &#8594; F</code><br>
							<code>x &#8614; f(x)</code>
						</p>
					</section>

					<section>
						<p>
							Il s’agit d’une <strong>transformation</strong><br>
							d’une valeur appartement à l’ensemble de départ<br>
							vers une valeur appartenant à l’ensemble d’arrivée.
						</p>
					</section>

					<section data-transition="none">
						<h4>Exemple : des tâches et leur statut</h4>
						<img src="img/tasks-01.png" alt="des statuts de tâche">
					</section>

					<section data-transition="none">
						<h4>Des transitions entre tâches</h4>
						<img src="img/tasks-02.png" alt="des statuts de tâche et des transitions">
					</section>

					<section data-transition="none">
						<h4>Ensembles de départ et d'arrivée</h4>
						<img src="img/tasks-03.png" alt="ensemble de départ et ensemble d’arrivée de findTransitions()">
					</section>

					<section>
						<pre><code class="language-scala">enum TaskStatus:
  case Created, Started, InReview, Done</code></pre>
						<pre class="fragment"><code class="language-scala">enum TaskTransition:
  case Start, Finish, RequestChange, Accept</code></pre>
						<pre class="fragment"><code class="language-scala">def findTransitions: TaskStatus => Seq[TaskTransition] =
  case Created  => Seq(Start)
  case Started  => Seq(Finish)
  case InReview => Seq(RequestChange, Accept)
  case Done     => Seq()</code></pre>
					</section>

					<section>
						<h4>Règle tirée de la réalité</h4>
						<p>Toujours chercher à diminuer la taille des ensembles de départ et d'arrivée permet de</p>
						<ol>
							<li>Simplifier le code et la lisibilité</li>
							<li>Éviter les bugs</li>
							<li>Éviter les attaques</li>
							<li>Ne pas implémenter des cas qui ne serviront jamais</li>
						</ol>
					</section>

					<section data-background-color="#003366">
						<h4>Travail pratique</h4>
						<p>Mettre en place un environnement de développement pour écrire sa première fonction en Scala</p>
						<ol>
							<li>Télécharger <a href="https://www.jetbrains.com/fr-fr/idea/download">IntelliJ IDEA Community Edition</a></li>
							<li>Installer IntelliJ IDEA Community Edition</li>
							<li>Installer le plugin Scala</li>
							<li>Générer un nouveau projet</li>
						</ol>
					</section>

					<section data-background-color="#003366">
						<h4>Travail pratique</h4>
						<img src="img/new-project.png" alt="Nouveau projet avec IntelliJ IDEA Community Edition" style="max-width: 75%">
					</section>

					<section data-background-color="#003366">
						<h4>Travail pratique</h4>
						<img src="img/new-project-firstFunction.png" alt="Résultat de l’exécution de notre première fonction" style="max-width: 70%">
					</section>

					<section>
						<h4>Caractéristiques d’une fonction</h4>
						<ul>
							<li>totale</li>
							<li>déterministe</li>
							<li>sans effet de bord</li>
						</ul>
					</section>
				</section>

				<section aria-description="1.2 Pureté">
					<section>
						<h3>Pureté</h3>
					</section>

					<section>
                        <pre><code class="language-scala">def sayHello(niceMessage: String): Unit =
  println(s"Hello $niceMessage")</code></pre>

                        <pre class="fragment"><code class="language-scala">sayHello("world!")</code></pre>

						<pre class="fragment"><code class="language-plaintext">Hello world!</code></pre>
					</section>

					<section>
                        <pre><code class="language-scala">def dice(): Int =
  Random.nextInt(6) + 1</code></pre>

                        <pre class="fragment"><code class="language-scala">dice()
val res0: Int = 5</code></pre>

						<pre class="fragment"><code class="language-scala">dice()
val res1: Int = 3</code></pre>
					</section>

					<section>
                        <pre><code class="language-scala">def nowPlus(days: Long): Instant =
  Instant.now().plus(days, ChronoUnit.DAYS)</code></pre>

                        <pre class="fragment"><code class="language-scala">nowPlus(3)
val res0: java.time.Instant = 2024-03-05T18:55:34.125784Z</code></pre>

						<pre class="fragment"><code class="language-scala">nowPlus(5)
val res1: java.time.Instant = 2024-03-07T18:55:34.215660Z</code></pre>
					</section>

					<section>
                        <pre><code class="language-scala">def saveArticle(id: UUID, content: String, author: Author)(
    database: Database
): Boolean =
  database.executeQuery(
    """INSERT INTO Article(id, content, author_name, author_email)
      |VALUES (:id, :content, :author_name, :author_email);
      |""".stripMargin,
    "id" -> id,
    "content" -> content,
    "author_name" -> author.name,
    "author_email" -> author.email
  )</code></pre>

						<pre class="fragment"><code class="language-scala">saveArticle(
    UUID.fromString("0d975fff-44dc-4110-b21a-1f31148969b8"),
    "&lt;p&gt;Great content&lt;/p&gt;",
    Author("Sébastian", "seb@example.com")
  )(postgresql)
val res0: Boolean = true</code></pre>
					</section>

					<section>
						<p>Toutes ces fonctions sont <em>impures</em> car :</p>
						<ul>
							<li>Deux appels successifs ne produisent pas la même valeur en retour ;</li>
							<li>Elles créent des effets de bord.</li>
						</ul>
					</section>

					<section>
						<h4>Pourquoi les fonctions pures sont-elles intéressantes ?</h4>
						<ul>
							<li class="fragment">transparence référentielle</li>
							<li class="fragment">immuabilité
								<ul>
									<li>des paramètres en entrée</li>
									<li>une valeur produite en retour</li>
								</ul>
						</ul>
						<p class="fragment">Permet donc des <strong>optimisations massivement parallélisables</strong></p>
					</section>
				</section>

				<section aria-description="1.3 Composition">
					<section>
						<h3>Composition</h3>
					</section>

					<section>
						<h4>Définition mathématique</h4>
						<p><code>f &#8728; g</code></p>
						<p><code>f(g(x))</code></p>
					</section>

					<section>
						<h4>D’un point de vue génie logiciel</h4>
						<p>Il s’agit d’un moyen de garantir</p>
						<ol>
							<li>la ré-utilisabilité du code</li>
							<li>le bon niveau d’abstraction</li>
							<li>la lisibilité</li>
						</ol>
					</section>

					<section>
						<pre><code class="language-scala">case class User(name: String, age: Int)</code></pre>

						<pre class="fragment"><code class="language-scala">enum Category:
  case Young, Adult, Old</code></pre>

						<pre class="fragment"><code class="language-scala">val categoryByMaxAges: Map[Int, Category] =
  Map(
    24 -> Category.Young,
    64 -> Category.Adult,
    Integer.MAX_VALUE -> Category.Old
  )</code></pre>

						<pre class="fragment"><code class="language-scala">val discountByCategories: Map[Category, Int] =
  Map(
    Category.Young -> 25,
    Category.Adult -> 0,
    Category.Old -> 35
  )</code></pre>
					</section>

					<section>
						<pre><code class="language-scala">def computePrice(
    user: User,
    categories: Map[Int, Category],
    price: Long,
    discounts: Map[Category, Int]
): Long = price - price * discounts(
  categories
    .filter { case (maxAge, category) => maxAge >= user.age }
    .minBy { case (maxAge, category) => maxAge }
    ._2
) / 100</code></pre>

						<pre class="fragment"><code class="language-scala">computePrice(          computePrice(          computePrice(
  User("Emma", 16),      User("Nicolas", 41),   User("Martine", 67),
  categoryByMaxAges,     categoryByMaxAges,     categoryByMaxAges,
  price = 1999,          price = 5500,          price = 4999,
  discountByCategories   discountByCategories   discountByCategories
)                      )                      )
val res0: Long = 1500  val res1: Long = 5500  val res2: Long = 3250</code></pre>
					</section>

					<section>
						<h3>Décomposons</h3>
					</section>

					<section>
						<pre><code class="language-scala">
def computePrice(
    user: User,
    categories: Map[Int, Category],
    price: Long,
    discounts: Map[Category, Int]
): Long =
  computePrice(
    price,
    computeDiscount(user, categories, discounts)
  )
						</code></pre>
					</section>

					<section>
						<pre><code class="language-scala">
def computePrice(price: Long, discount: Long): Long =
  price - price * discount / 100
						</code></pre>
					</section>

					<section>
						<pre><code class="language-scala">
def computeDiscount(
    user: User,
    categories: Map[Int, Category],
    discounts: Map[Category, Int]
): Long = discounts(findCategory(user, categories))
						</code></pre>
					</section>

					<section>
						<pre><code class="language-scala">
def findCategory(
    user: User,
    categories: Map[Int, Category]
): Category =
  val (_, category) = categories
    .filter { case (maxAge, category) => maxAge >= user.age }
    .minBy { case (maxAge, category) => maxAge }
  category
						</code></pre>
					</section>

					<section>
						<h4>Les fonctions : ces citoyens de premier ordre</h4>
					</section>

					<section>
						<p>Une fonction est considérée comme un type de données comme les autres.</p>
						<ul>
							<li class="fragment">peut-être passée en argument d’une autre fonction</li>
						</ul>
					</section>

					<section>
						<pre><code class="language-scala">def logBeforeAndAfter(message: String, task: () => Unit): Unit =
  println(s"before $message")
  task()
  println(s" after $message")</code></pre>

						<pre class="fragment"><code class="language-scala">logBeforeAndAfter("hello", () => { println("Hello World!") })</code></pre>

						<pre class="fragment"><code class="language-plaintext">before hello
Hello World!
 after hello</code></pre>
					</section>

					<section>
						<pre><code class="language-scala">def logBeforeAndAfterResult(
    message: String,
    computeResult: String => Long
): Unit =
  println(s"before $message")
  println(s"result ${computeResult(message)}")
  println(s" after $message")</code></pre>

						<pre class="fragment"><code class="language-scala">logBeforeAndAfterResult("hello", message => message.length)</code></pre>
						<pre class="fragment"><code class="language-plaintext">before hello
result 5
 after hello</code></pre>
					</section>

					<section>
						<p>Une fonction est considérée comme un type de données comme les autres.</p>
						<ul>
							<li>peut-être passée en argument d’une autre fonction</li>
							<li class="fragment">peut-être retournée par une autre fonction</li>
						</ul>
					</section>

					<section>
						<pre><code class="language-scala">def operationToCompute(operation: String): (Long, Long) => Long =
  operation match
    case "add"      => (left, right) => left + right
    case "subtract" => (left, right) => left - right
    case "multiply" => (left, right) => left * right
    case _          => (left, right) => Long.MinValue</code></pre>

						<pre class="fragment"><code class="language-scala">operationToCompute("add"     )(3, 2)
val res0: Long = 5</code></pre>

						<pre class="fragment"><code class="language-scala">operationToCompute("subtract")(3, 2)
val res1: Long = 1</code></pre>

						<pre class="fragment"><code class="language-scala">operationToCompute("multiply")(3, 2)
val res2: Long = 6</code></pre>

						<pre class="fragment"><code class="language-scala">operationToCompute("divide"  )(3, 2)
val res3: Long = -9223372036854775808</code></pre>
					</section>
				</section>

				<section aria-description="1.4 Récursivité">
					<section>
						<h3>Récursivité</h3>
					</section>

					<section>
						<p>La possibilité pour une fonction de se rappeler elle-même. Permet de traiter :</p>
						<ul>
							<li>une structure de données elle-même récursive</li>
							<li>une collection</li>
						</ul>
					</section>

					<section>
						<h4>Implémentation</h4>
						<ol>
							<li>trouver une ou plusieurs conditions d’arrêt</li>
							<li>se rappeler soi-même avec des données transformées</li>
						</ol>
					</section>

					<section>
						<h4>Récursion terminale</h4>
						<p>L’appel récursif est la dernière évaluation dans l’implémentation de la fonction</p>
						<p>Permet d’éviter des épuisements de la pile d’exécution (aka StackOverflow®)</p>
					</section>

					<section>
						<h4>Exemple: lire un flux</h4>
						<pre><code class="language-scala">val input = """34
              |84
              |12
              |
              |32
              |28
              |9
              |7""".stripMargin</code></pre>
						<pre class="fragment"><code class="language-scala">@tailrec
def sums(
    input: List[String],
    acc: Seq[Long] = Vector.empty,
    sum: Long = 0
): Seq[Long] =
  input match
    case Nil        => acc :+ sum
    case "" :: tail => sums(tail, acc :+ sum)
    case n :: tail  => sums(tail, acc, sum + n.toLong)</code></pre>
						<pre class="fragment"><code class="language-scala">sums(input.linesIterator.toList)
val res0: Seq[Long] = Vector(130, 76)</code></pre>
					</section>
				</section>

				<section aria-description="2. Introduction à Scala">
					<h2>Introduction à Scala</h2>
				</section>

				<section aria-description="2.1 Présentation fonctionnelle de Scala">
					<h2>Présentation fonctionnelle de Scala</h2>
				</section>

				<section aria-description="2.2 Présentation objet de Scala">
					<h2>Présentation objet de Scala</h2>
					<p>
						Press <strong>ESC</strong> to enter the slide overview.
					</p>
					<p>
						Hold down the <strong>alt</strong> key (<strong>ctrl</strong> in Linux) and click on any element to zoom towards it using <a href="http://lab.hakim.se/zoom-js">zoom.js</a>. Click again to zoom back out.
					</p>
					<p>
						(NOTE: Use ctrl + click in Linux.)
					</p>
				</section>

				<section aria-description="3. Types et polymorphisme">
					<h2>Types et polymorphisme</h2>
				</section>

				<section aria-description="4. Gestion des effets en programmation fonctionnelle">
					<h2>Gestion des effets en programmation fonctionnelle</h2>
				</section>

				<section aria-description="5. Manipulations et cas pratiques">
					<h2>Manipulations et cas pratiques</h2>
				</section>

			</div>

		</div>

		<script src="../lib/revealjs/dist/reveal.js"></script>
		<script src="../lib/revealjs/plugin/highlight/highlight.js"></script>
		<script>

			// Also available as an ES module, see:
			// https://revealjs.com/initialization/
			Reveal.initialize({
				controls: true,
				progress: true,
				center: true,
				hash: true,

				plugins: [ RevealHighlight ]
			});

		</script>

	</body>
</html>